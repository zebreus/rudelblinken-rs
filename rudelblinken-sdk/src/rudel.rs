// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * pub-export-macro
//   * disable_custom_section_link_helpers
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod rudel {
    pub mod base {
        /// base is the interface for all basic functionality of the rudelblinken system
        #[allow(dead_code, clippy::all)]
        pub mod base {
            use super::super::super::_rt;
            /// The semantic version of a module
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct SemanticVersion {
                pub major: u8,
                pub minor: u8,
                pub patch: u8,
            }
            impl ::core::fmt::Debug for SemanticVersion {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SemanticVersion")
                        .field("major", &self.major)
                        .field("minor", &self.minor)
                        .field("patch", &self.patch)
                        .finish()
                }
            }
            /// Level of a log entry
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum LogLevel {
                Error,
                Warning,
                Info,
                Debug,
                Trace,
            }
            impl ::core::fmt::Debug for LogLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
                        LogLevel::Warning => f.debug_tuple("LogLevel::Warning").finish(),
                        LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
                        LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
                        LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
                    }
                }
            }
            impl LogLevel {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> LogLevel {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => LogLevel::Error,
                        1 => LogLevel::Warning,
                        2 => LogLevel::Info,
                        3 => LogLevel::Debug,
                        4 => LogLevel::Trace,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the rudel base
            ///
            /// If your module requests newer versions of the modules than the host implements, it will attempt to link its old ones anyways and make them conforme to the requested signatures. You can use this function to get the actual version of the host functions.
            ///
            /// If your module requests older versions of the host modules, the host will link compatible functions if available, or abort during linking.
            ///
            /// The host will mock out all functions it can not link.
            pub fn get_base_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-base-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// You need to yield periodically, as the watchdog will kill you if you dont
            ///
            /// Will try to sleep for the given duration while still serving callbacks
            ///
            /// Use micros = 0 to sleep for the minimum duration
            ///
            /// Returns the new fuel amount
            pub fn yield_now(micros: u64) -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "yield-now"]
                        fn wit_import(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(_rt::as_i64(&micros));
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the remaining fuel
            pub fn get_remaining_fuel() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-remaining-fuel"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sleep for a given amount of time without yielding
            pub fn sleep(micros: u64) {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "sleep"]
                        fn wit_import(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i64(&micros));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the number of microseconds that have passed since boot
            pub fn time() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "time"]
                        fn wit_import() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log a message
            pub fn log(level: LogLevel, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "log"]
                        fn wit_import(_: i32, _: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(level.clone() as i32, ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// The name of this host. It is guaranteed to be unique, and will not change during the lifetime of the host.
            ///
            /// The name is returned as a list of 16 bytes to avoid the need for allocations on the host side, as the buffer will be allocated by the guest. The name is UTF-8 encoded, and the buffer will be zero padded after the end of the string.
            ///
            /// Once fixed size lists gets stabilized in WIT, this will be changed to a list<u8, 16>. That should not affect the ABI as the representation of a tuple and a fixed size list is the same.
            ///
            /// Your host bindings should provide a wrapper for this that converts the list to a string.
            pub fn get_name() -> (
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
            ) {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-name"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(3).cast::<u8>());
                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                    let l6 = i32::from(*ptr0.add(5).cast::<u8>());
                    let l7 = i32::from(*ptr0.add(6).cast::<u8>());
                    let l8 = i32::from(*ptr0.add(7).cast::<u8>());
                    let l9 = i32::from(*ptr0.add(8).cast::<u8>());
                    let l10 = i32::from(*ptr0.add(9).cast::<u8>());
                    let l11 = i32::from(*ptr0.add(10).cast::<u8>());
                    let l12 = i32::from(*ptr0.add(11).cast::<u8>());
                    let l13 = i32::from(*ptr0.add(12).cast::<u8>());
                    let l14 = i32::from(*ptr0.add(13).cast::<u8>());
                    let l15 = i32::from(*ptr0.add(14).cast::<u8>());
                    let l16 = i32::from(*ptr0.add(15).cast::<u8>());
                    (
                        l1 as u8,
                        l2 as u8,
                        l3 as u8,
                        l4 as u8,
                        l5 as u8,
                        l6 as u8,
                        l7 as u8,
                        l8 as u8,
                        l9 as u8,
                        l10 as u8,
                        l11 as u8,
                        l12 as u8,
                        l13 as u8,
                        l14 as u8,
                        l15 as u8,
                        l16 as u8,
                    )
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the configuration for this guest, as configured over BLE. The
            /// semantics of the configuration depend on the guest.
            pub fn get_config() -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-config"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    _rt::Vec::from_raw_parts(l1.cast(), len3, len3)
                }
            }
        }
        /// Use this interface to control the hardware
        #[allow(dead_code, clippy::all)]
        pub mod hardware {
            use super::super::super::_rt;
            pub type SemanticVersion = super::super::super::rudel::base::base::SemanticVersion;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct LedColor {
                pub red: u8,
                pub green: u8,
                pub blue: u8,
            }
            impl ::core::fmt::Debug for LedColor {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LedColor")
                        .field("red", &self.red)
                        .field("green", &self.green)
                        .field("blue", &self.blue)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct LedInfo {
                pub color: LedColor,
                pub max_lux: u16,
            }
            impl ::core::fmt::Debug for LedInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LedInfo")
                        .field("color", &self.color)
                        .field("max-lux", &self.max_lux)
                        .finish()
                }
            }
            /// Information about the ambient light sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum AmbientLightType {
                None,
                Basic,
            }
            impl ::core::fmt::Debug for AmbientLightType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AmbientLightType::None => {
                            f.debug_tuple("AmbientLightType::None").finish()
                        }
                        AmbientLightType::Basic => {
                            f.debug_tuple("AmbientLightType::Basic").finish()
                        }
                    }
                }
            }
            impl AmbientLightType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> AmbientLightType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => AmbientLightType::None,
                        1 => AmbientLightType::Basic,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Information about the vibration sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum VibrationSensorType {
                None,
                Ball,
            }
            impl ::core::fmt::Debug for VibrationSensorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        VibrationSensorType::None => {
                            f.debug_tuple("VibrationSensorType::None").finish()
                        }
                        VibrationSensorType::Ball => {
                            f.debug_tuple("VibrationSensorType::Ball").finish()
                        }
                    }
                }
            }
            impl VibrationSensorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> VibrationSensorType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => VibrationSensorType::None,
                        1 => VibrationSensorType::Ball,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Information about the supply voltage sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum VoltageSensorType {
                None,
                Basic,
            }
            impl ::core::fmt::Debug for VoltageSensorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        VoltageSensorType::None => {
                            f.debug_tuple("VoltageSensorType::None").finish()
                        }
                        VoltageSensorType::Basic => {
                            f.debug_tuple("VoltageSensorType::Basic").finish()
                        }
                    }
                }
            }
            impl VoltageSensorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> VoltageSensorType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => VoltageSensorType::None,
                        1 => VoltageSensorType::Basic,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the hardware interface provided by the runtime.
            ///
            /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
            pub fn get_hardware_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-hardware-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    super::super::super::rudel::base::base::SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Lowlevel function to set the intensities of multiple LEDs
            ///
            /// The values are in lux in the main direction of the LED
            ///
            /// You should probably not use this function directly, but use a higher level abstraction instead
            ///
            /// The first-id is the index of the first LED to set. If the lux list is shorter than the number of LEDs, the remaining LEDs will not be modified. If the lux list is longer than the number of LEDs, the remaining values will be ignored.
            pub fn set_leds(first_id: u16, lux: &[u16]) -> u32 {
                unsafe {
                    let vec0 = lux;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "set-leds"]
                        fn wit_import(_: i32, _: *mut u8, _: usize) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(_rt::as_i32(&first_id), ptr0.cast_mut(), len0);
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Convenience function to set all LEDs
            pub fn set_rgb(color: LedColor, lux: u32) -> u32 {
                unsafe {
                    let LedColor { red: red0, green: green0, blue: blue0 } = color;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "set-rgb"]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32, _: i32, _: i32) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        _rt::as_i32(red0),
                        _rt::as_i32(green0),
                        _rt::as_i32(blue0),
                        _rt::as_i32(&lux),
                    );
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get information about the number of LEDs
            pub fn led_count() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "led-count"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get information about a specific LED
            ///
            /// If the id does not exist, the function will return a led-info with all values set to 0
            pub fn get_led_info(id: u16) -> LedInfo {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 6]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 6]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-led-info"]
                        fn wit_import(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i32(&id), ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(4).cast::<u16>());
                    LedInfo {
                        color: LedColor {
                            red: l1 as u8,
                            green: l2 as u8,
                            blue: l3 as u8,
                        },
                        max_lux: l4 as u16,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Information about the ambient light sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            pub fn get_ambient_light_type() -> AmbientLightType {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ambient-light-type"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    AmbientLightType::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the current ambient light level
            ///
            /// The value is in lux
            pub fn get_ambient_light() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ambient-light"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Vibration sensor type.
            pub fn get_vibration_sensor_type() -> VibrationSensorType {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-vibration-sensor-type"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    VibrationSensorType::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get a measure of the vibration level
            ///
            /// TODO: Figure out what this should return
            pub fn get_vibration() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-vibration"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Voltage sensor type.
            pub fn get_voltage_sensor_type() -> VibrationSensorType {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-voltage-sensor-type"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    VibrationSensorType::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the current supply voltage
            ///
            /// The value is in millivolts
            pub fn get_voltage() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-voltage"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
        }
        /// Control ble stuff
        #[allow(dead_code, clippy::all)]
        pub mod ble {
            use super::super::super::_rt;
            pub type SemanticVersion = super::super::super::rudel::base::base::SemanticVersion;
            /// A service UUID, can be a shortened one
            #[derive(Clone, Copy)]
            pub enum ServiceUuid {
                Uuid16(u16),
                Uuid32(u32),
                Uuid128((u64, u64)),
            }
            impl ::core::fmt::Debug for ServiceUuid {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ServiceUuid::Uuid16(e) => {
                            f.debug_tuple("ServiceUuid::Uuid16").field(e).finish()
                        }
                        ServiceUuid::Uuid32(e) => {
                            f.debug_tuple("ServiceUuid::Uuid32").field(e).finish()
                        }
                        ServiceUuid::Uuid128(e) => {
                            f.debug_tuple("ServiceUuid::Uuid128").field(e).finish()
                        }
                    }
                }
            }
            /// Service specific data
            #[derive(Clone)]
            pub struct ServiceData {
                pub uuid: ServiceUuid,
                pub data: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for ServiceData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ServiceData")
                        .field("uuid", &self.uuid)
                        .field("data", &self.data)
                        .finish()
                }
            }
            /// Manufacturer specific data
            #[derive(Clone)]
            pub struct ManufacturerData {
                pub company_id: u16,
                pub data: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for ManufacturerData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ManufacturerData")
                        .field("company-id", &self.company_id)
                        .field("data", &self.data)
                        .finish()
                }
            }
            /// Configure the BLE advertisements
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct AdvertisementInterval {
                pub min_interval: u16,
                pub max_interval: u16,
            }
            impl ::core::fmt::Debug for AdvertisementInterval {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AdvertisementInterval")
                        .field("min-interval", &self.min_interval)
                        .field("max-interval", &self.max_interval)
                        .finish()
                }
            }
            /// Sendable BLE advertisement data
            ///
            /// Can be at most 31 bytes - (size of the name + 6 bytes)
            #[derive(Clone)]
            pub struct EncodedData {
                /// Include the transmission power. (3 bytes)
                pub include_tx_power: bool,
                /// service UUIDs (2 bytes per used class (16, 32, 128 bit UUID) + size of the UUIDs)
                pub uuids: _rt::Vec<ServiceUuid>,
                /// service data (2 byte + size of the UUID + size of data) for each service data)
                pub service_data: _rt::Vec<ServiceData>,
                /// appearance (4 byte)
                pub appearance: Option<u16>,
                /// manufacturer specific data (2 byte + 2 byte company ID + size of data)
                pub manufacturer_data: Option<ManufacturerData>,
            }
            impl ::core::fmt::Debug for EncodedData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EncodedData")
                        .field("include-tx-power", &self.include_tx_power)
                        .field("uuids", &self.uuids)
                        .field("service-data", &self.service_data)
                        .field("appearance", &self.appearance)
                        .field("manufacturer-data", &self.manufacturer_data)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the hardware interface provided by the runtime.
            ///
            /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
            pub fn get_ble_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ble-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    super::super::super::rudel::base::base::SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Configure the interval in which BLE advertisements are sent
            ///
            /// Returns an error if the interval is not valid
            pub fn configure_advertisement_interval(
                interval: AdvertisementInterval,
            ) -> Result<(), ()> {
                unsafe {
                    let AdvertisementInterval {
                        min_interval: min_interval0,
                        max_interval: max_interval0,
                    } = interval;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "configure-advertisement-interval"]
                        fn wit_import(_: i32, _: i32) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        _rt::as_i32(min_interval0),
                        _rt::as_i32(max_interval0),
                    );
                    match ret {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = ();
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Set the advertisement data. The device name will also be added to the advertisement.
            ///
            /// If you need more control use set-advertisement-data-raw
            ///
            /// Will fail if your data is too long
            pub fn set_advertisement_data(data: &EncodedData) -> Result<(), ()> {
                unsafe {
                    let EncodedData {
                        include_tx_power: include_tx_power0,
                        uuids: uuids0,
                        service_data: service_data0,
                        appearance: appearance0,
                        manufacturer_data: manufacturer_data0,
                    } = data;
                    let vec2 = uuids0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec2.len() * 24,
                        8,
                    );
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 24);
                        {
                            match e {
                                ServiceUuid::Uuid16(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                ServiceUuid::Uuid32(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                ServiceUuid::Uuid128(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let (t1_0, t1_1) = e;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(t1_0);
                                    *base.add(16).cast::<i64>() = _rt::as_i64(t1_1);
                                }
                            }
                        }
                    }
                    let vec6 = service_data0;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * 32,
                        8,
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6.add(i * 32);
                        {
                            let ServiceData { uuid: uuid3, data: data3 } = e;
                            match uuid3 {
                                ServiceUuid::Uuid16(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
                                }
                                ServiceUuid::Uuid32(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                }
                                ServiceUuid::Uuid128(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let (t4_0, t4_1) = e;
                                    *base.add(8).cast::<i64>() = _rt::as_i64(t4_0);
                                    *base.add(16).cast::<i64>() = _rt::as_i64(t4_1);
                                }
                            }
                            let vec5 = data3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(28).cast::<usize>() = len5;
                            *base.add(24).cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    }
                    let (result7_0, result7_1) = match appearance0 {
                        Some(e) => (1i32, _rt::as_i32(e)),
                        None => (0i32, 0i32),
                    };
                    let (result10_0, result10_1, result10_2, result10_3) = match manufacturer_data0 {
                        Some(e) => {
                            let ManufacturerData {
                                company_id: company_id8,
                                data: data8,
                            } = e;
                            let vec9 = data8;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            (1i32, _rt::as_i32(company_id8), ptr9.cast_mut(), len9)
                        }
                        None => (0i32, 0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "set-advertisement-data"]
                        fn wit_import(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        match include_tx_power0 {
                            true => 1,
                            false => 0,
                        },
                        result2,
                        len2,
                        result6,
                        len6,
                        result7_0,
                        result7_1,
                        result10_0,
                        result10_1,
                        result10_2,
                        result10_3,
                    );
                    if layout2.size() != 0 {
                        _rt::alloc::dealloc(result2.cast(), layout2);
                    }
                    if layout6.size() != 0 {
                        _rt::alloc::dealloc(result6.cast(), layout6);
                    }
                    match ret {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = ();
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Set the raw advertisement data. There will be no additional properties added.
            ///
            /// Can be at most 31 bytes
            ///
            /// Will fail if your data is too long
            pub fn set_advertisement_data_raw(data: &[u8]) -> Result<(), ()> {
                unsafe {
                    let vec0 = data;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "set-advertisement-data-raw"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    match ret {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = ();
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Disable decoded advertisements
            ///
            /// true => `on-event` will only receive raw advertisements
            /// false => `on-event` will decode advertisements, if possible
            pub fn disable_decoded_advertisements(disable: bool) {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "disable-decoded-advertisements"]
                        fn wit_import(_: i32);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(
                        match &disable {
                            true => 1,
                            false => 0,
                        },
                    );
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod rudel {
        pub mod base {
            #[allow(dead_code, clippy::all)]
            pub mod ble_guest {
                use super::super::super::super::_rt;
                pub type ServiceUuid = super::super::super::super::rudel::base::ble::ServiceUuid;
                pub type ServiceData = super::super::super::super::rudel::base::ble::ServiceData;
                pub type ManufacturerData = super::super::super::super::rudel::base::ble::ManufacturerData;
                wit_bindgen::rt::bitflags::bitflags! {
                    #[doc = " TODO: Check order"] #[derive(PartialEq, Eq, PartialOrd,
                    Ord, Hash, Debug, Clone, Copy)] pub struct AdvertisementFlags : u8 {
                    #[doc = " LE Limited Discoverable Mode"] const LIMITED_DISCOVERABLE =
                    1 << 0; #[doc = " LE General Discoverable Mode"] const
                    GENERAL_DISCOVERABLE = 1 << 1; #[doc = " BR/EDR Not Supported"] const
                    BR_EDR_NOT_SUPPORTED = 1 << 2; #[doc =
                    " Simultaneous LE and BR/EDR to Same Device Capable (Controller)"]
                    const SIMULTANEOUS_CONTROLLER = 1 << 3; #[doc =
                    " Simultaneous LE and BR/EDR to Same Device Capable (Host)"] const
                    SIMULTANEOUS_HOST = 1 << 4; }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AdvertisementType {
                    /// indirect advertising
                    Indirect,
                    /// direct advertising
                    DirectInd,
                    /// indirect scan response
                    IndirectScan,
                    /// indirect advertising - not connectable
                    IndirectNotConnectable,
                    /// scan responst
                    ScanResponse,
                }
                impl ::core::fmt::Debug for AdvertisementType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AdvertisementType::Indirect => {
                                f.debug_tuple("AdvertisementType::Indirect").finish()
                            }
                            AdvertisementType::DirectInd => {
                                f.debug_tuple("AdvertisementType::DirectInd").finish()
                            }
                            AdvertisementType::IndirectScan => {
                                f.debug_tuple("AdvertisementType::IndirectScan").finish()
                            }
                            AdvertisementType::IndirectNotConnectable => {
                                f.debug_tuple("AdvertisementType::IndirectNotConnectable")
                                    .finish()
                            }
                            AdvertisementType::ScanResponse => {
                                f.debug_tuple("AdvertisementType::ScanResponse").finish()
                            }
                        }
                    }
                }
                impl AdvertisementType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AdvertisementType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AdvertisementType::Indirect,
                            1 => AdvertisementType::DirectInd,
                            2 => AdvertisementType::IndirectScan,
                            3 => AdvertisementType::IndirectNotConnectable,
                            4 => AdvertisementType::ScanResponse,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Decoded BLE advertisement
                #[derive(Clone)]
                pub struct DecodedData {
                    /// name of the remote device
                    pub name: Option<_rt::String>,
                    /// flags
                    pub advertisement_flags: AdvertisementFlags,
                    /// tx power
                    pub tx_power: Option<u8>,
                    /// service UUIDs
                    pub uuids: _rt::Vec<ServiceUuid>,
                    /// service data
                    pub service_data: _rt::Vec<ServiceData>,
                    /// appearance
                    pub appearance: Option<u16>,
                    /// manufacturer specific data
                    pub manufacturer_data: Option<ManufacturerData>,
                }
                impl ::core::fmt::Debug for DecodedData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("DecodedData")
                            .field("name", &self.name)
                            .field("advertisement-flags", &self.advertisement_flags)
                            .field("tx-power", &self.tx_power)
                            .field("uuids", &self.uuids)
                            .field("service-data", &self.service_data)
                            .field("appearance", &self.appearance)
                            .field("manufacturer-data", &self.manufacturer_data)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub enum AdvertisementData {
                    /// Decoded advertisement data
                    Decoded(DecodedData),
                    /// Raw advertisement data. Returned if there were some fields that failed decoding
                    Raw(_rt::Vec<u8>),
                }
                impl ::core::fmt::Debug for AdvertisementData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AdvertisementData::Decoded(e) => {
                                f.debug_tuple("AdvertisementData::Decoded")
                                    .field(e)
                                    .finish()
                            }
                            AdvertisementData::Raw(e) => {
                                f.debug_tuple("AdvertisementData::Raw").field(e).finish()
                            }
                        }
                    }
                }
                /// Decoded BLE advertisement
                #[derive(Clone)]
                pub struct Advertisement {
                    /// When the advertisement was received
                    /// There may be some delay between when the advertisement was received and when the WASM guest is notified
                    pub received_at: u64,
                    /// The address of the sender 48bit integer
                    pub address: u64,
                    /// Received signal strength
                    pub rssi: i8,
                    /// Received advertisement type
                    pub advertisement_type: AdvertisementType,
                    /// Received data
                    /// Will be decoded if it can be decoded
                    pub data: AdvertisementData,
                }
                impl ::core::fmt::Debug for Advertisement {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Advertisement")
                            .field("received-at", &self.received_at)
                            .field("address", &self.address)
                            .field("rssi", &self.rssi)
                            .field("advertisement-type", &self.advertisement_type)
                            .field("data", &self.data)
                            .finish()
                    }
                }
                /// A ble event
                /// For now only advertisements
                #[derive(Clone)]
                pub enum BleEvent {
                    Advertisement(Advertisement),
                }
                impl ::core::fmt::Debug for BleEvent {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            BleEvent::Advertisement(e) => {
                                f.debug_tuple("BleEvent::Advertisement").field(e).finish()
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_event_cabi<T: Guest>(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    let v45 = match l0 {
                        n => {
                            debug_assert_eq!(n, 0, "invalid enum discriminant");
                            let e45 = {
                                let l1 = *arg0.add(8).cast::<i64>();
                                let l2 = *arg0.add(16).cast::<i64>();
                                let l3 = i32::from(*arg0.add(24).cast::<i8>());
                                let l4 = i32::from(*arg0.add(25).cast::<u8>());
                                let l5 = i32::from(*arg0.add(28).cast::<u8>());
                                let v44 = match l5 {
                                    0 => {
                                        let e44 = {
                                            let l6 = i32::from(*arg0.add(32).cast::<u8>());
                                            let l10 = i32::from(*arg0.add(44).cast::<u8>());
                                            let l11 = i32::from(*arg0.add(45).cast::<u8>());
                                            let l13 = *arg0.add(48).cast::<*mut u8>();
                                            let l14 = *arg0.add(52).cast::<usize>();
                                            let base21 = l13;
                                            let len21 = l14;
                                            let mut result21 = _rt::Vec::with_capacity(len21);
                                            for i in 0..len21 {
                                                let base = base21.add(i * 24);
                                                let e21 = {
                                                    let l15 = i32::from(*base.add(0).cast::<u8>());
                                                    use super::super::super::super::rudel::base::ble::ServiceUuid as V20;
                                                    let v20 = match l15 {
                                                        0 => {
                                                            let e20 = {
                                                                let l16 = i32::from(*base.add(8).cast::<u16>());
                                                                l16 as u16
                                                            };
                                                            V20::Uuid16(e20)
                                                        }
                                                        1 => {
                                                            let e20 = {
                                                                let l17 = *base.add(8).cast::<i32>();
                                                                l17 as u32
                                                            };
                                                            V20::Uuid32(e20)
                                                        }
                                                        n => {
                                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                            let e20 = {
                                                                let l18 = *base.add(8).cast::<i64>();
                                                                let l19 = *base.add(16).cast::<i64>();
                                                                (l18 as u64, l19 as u64)
                                                            };
                                                            V20::Uuid128(e20)
                                                        }
                                                    };
                                                    v20
                                                };
                                                result21.push(e21);
                                            }
                                            _rt::cabi_dealloc(base21, len21 * 24, 8);
                                            let l22 = *arg0.add(56).cast::<*mut u8>();
                                            let l23 = *arg0.add(60).cast::<usize>();
                                            let base33 = l22;
                                            let len33 = l23;
                                            let mut result33 = _rt::Vec::with_capacity(len33);
                                            for i in 0..len33 {
                                                let base = base33.add(i * 32);
                                                let e33 = {
                                                    let l24 = i32::from(*base.add(0).cast::<u8>());
                                                    use super::super::super::super::rudel::base::ble::ServiceUuid as V29;
                                                    let v29 = match l24 {
                                                        0 => {
                                                            let e29 = {
                                                                let l25 = i32::from(*base.add(8).cast::<u16>());
                                                                l25 as u16
                                                            };
                                                            V29::Uuid16(e29)
                                                        }
                                                        1 => {
                                                            let e29 = {
                                                                let l26 = *base.add(8).cast::<i32>();
                                                                l26 as u32
                                                            };
                                                            V29::Uuid32(e29)
                                                        }
                                                        n => {
                                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                            let e29 = {
                                                                let l27 = *base.add(8).cast::<i64>();
                                                                let l28 = *base.add(16).cast::<i64>();
                                                                (l27 as u64, l28 as u64)
                                                            };
                                                            V29::Uuid128(e29)
                                                        }
                                                    };
                                                    let l30 = *base.add(24).cast::<*mut u8>();
                                                    let l31 = *base.add(28).cast::<usize>();
                                                    let len32 = l31;
                                                    super::super::super::super::rudel::base::ble::ServiceData {
                                                        uuid: v29,
                                                        data: _rt::Vec::from_raw_parts(l30.cast(), len32, len32),
                                                    }
                                                };
                                                result33.push(e33);
                                            }
                                            _rt::cabi_dealloc(base33, len33 * 32, 8);
                                            let l34 = i32::from(*arg0.add(64).cast::<u8>());
                                            let l36 = i32::from(*arg0.add(68).cast::<u8>());
                                            DecodedData {
                                                name: match l6 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l7 = *arg0.add(36).cast::<*mut u8>();
                                                            let l8 = *arg0.add(40).cast::<usize>();
                                                            let len9 = l8;
                                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                                l7.cast(),
                                                                len9,
                                                                len9,
                                                            );
                                                            _rt::string_lift(bytes9)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                advertisement_flags: AdvertisementFlags::empty()
                                                    | AdvertisementFlags::from_bits_retain(
                                                        ((l10 as u8) << 0) as _,
                                                    ),
                                                tx_power: match l11 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l12 = i32::from(*arg0.add(46).cast::<u8>());
                                                            l12 as u8
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                uuids: result21,
                                                service_data: result33,
                                                appearance: match l34 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l35 = i32::from(*arg0.add(66).cast::<u16>());
                                                            l35 as u16
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                manufacturer_data: match l36 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l37 = i32::from(*arg0.add(72).cast::<u16>());
                                                            let l38 = *arg0.add(76).cast::<*mut u8>();
                                                            let l39 = *arg0.add(80).cast::<usize>();
                                                            let len40 = l39;
                                                            super::super::super::super::rudel::base::ble::ManufacturerData {
                                                                company_id: l37 as u16,
                                                                data: _rt::Vec::from_raw_parts(l38.cast(), len40, len40),
                                                            }
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        AdvertisementData::Decoded(e44)
                                    }
                                    n => {
                                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                                        let e44 = {
                                            let l41 = *arg0.add(32).cast::<*mut u8>();
                                            let l42 = *arg0.add(36).cast::<usize>();
                                            let len43 = l42;
                                            _rt::Vec::from_raw_parts(l41.cast(), len43, len43)
                                        };
                                        AdvertisementData::Raw(e44)
                                    }
                                };
                                Advertisement {
                                    received_at: l1 as u64,
                                    address: l2 as u64,
                                    rssi: l3 as i8,
                                    advertisement_type: AdvertisementType::_lift(l4 as u8),
                                    data: v44,
                                }
                            };
                            BleEvent::Advertisement(e45)
                        }
                    };
                    T::on_event(v45);
                    _rt::cabi_dealloc(arg0, 88, 8);
                }
                pub trait Guest {
                    /// Check if the ble module is implemented
                    ///
                    /// The rudelblinken runtime will mock out all functions the it can not link.
                    /// If this function returns false you should not use any of the other functions
                    fn on_event(event: BleEvent);
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_rudel_base_ble_guest_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "rudel:base/ble-guest@0.0.1#on-event"] unsafe extern "C" fn
                        export_on_event(arg0 : * mut u8,) { $($path_to_types)*::
                        _export_on_event_cabi::<$ty > (arg0) } };
                    };
                }
                #[doc(hidden)]
                pub use __export_rudel_base_ble_guest_0_0_1_cabi;
            }
            #[allow(dead_code, clippy::all)]
            pub mod run {
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_run_cabi<T: Guest>() {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::run();
                }
                pub trait Guest {
                    /// Run the program.
                    fn run();
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_rudel_base_run_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name = "rudel:base/run@0.0.1#run"]
                        unsafe extern "C" fn export_run() { $($path_to_types)*::
                        _export_run_cabi::<$ty > () } };
                    };
                }
                #[doc(hidden)]
                pub use __export_rudel_base_run_0_0_1_cabi;
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
#[macro_export]
macro_rules! __export_rudel_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::rudel::base::ble_guest::__export_rudel_base_ble_guest_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::rudel::base::ble_guest);
        $($path_to_types_root)*::
        exports::rudel::base::run::__export_rudel_base_run_0_0_1_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::rudel::base::run); const _ : () = {
        #[cfg(target_arch = "wasm32")] #[link_section =
        "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel:imports and exports"]
        #[doc(hidden)] pub static __WIT_BINDGEN_COMPONENT_TYPE : [u8; 2360] = *
        b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xbc\x11\x01A\x02\x01\
A\x0e\x01B\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\
\0\x09yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06\
microsw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05\
level\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\
\0\x0a\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x03\
\0\x15rudel:base/base@0.0.1\x05\0\x02\x03\0\0\x10semantic-version\x01B\x1f\x02\x03\
\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x03\x03red}\x05green}\x04blu\
e}\x04\0\x09led-color\x03\0\x02\x01r\x02\x05color\x03\x07max-lux{\x04\0\x08led-i\
nfo\x03\0\x04\x01m\x02\x04none\x05basic\x04\0\x12ambient-light-type\x03\0\x06\x01\
m\x02\x04none\x04ball\x04\0\x15vibration-sensor-type\x03\0\x08\x01m\x02\x04none\x05\
basic\x04\0\x13voltage-sensor-type\x03\0\x0a\x01@\0\0\x01\x04\0\x14get-hardware-\
version\x01\x0c\x01p{\x01@\x02\x08first-id{\x03lux\x0d\0y\x04\0\x08set-leds\x01\x0e\
\x01@\x02\x05color\x03\x03luxy\0y\x04\0\x07set-rgb\x01\x0f\x01@\0\0y\x04\0\x09le\
d-count\x01\x10\x01@\x01\x02id{\0\x05\x04\0\x0cget-led-info\x01\x11\x01@\0\0\x07\
\x04\0\x16get-ambient-light-type\x01\x12\x04\0\x11get-ambient-light\x01\x10\x01@\
\0\0\x09\x04\0\x19get-vibration-sensor-type\x01\x13\x04\0\x0dget-vibration\x01\x10\
\x04\0\x17get-voltage-sensor-type\x01\x13\x04\0\x0bget-voltage\x01\x10\x03\0\x19\
rudel:base/hardware@0.0.1\x05\x02\x01B\x1d\x02\x03\x02\x01\x01\x04\0\x10semantic\
-version\x03\0\0\x01o\x02ww\x01q\x03\x06uuid16\x01{\0\x06uuid32\x01y\0\x07uuid12\
8\x01\x02\0\x04\0\x0cservice-uuid\x03\0\x03\x01p}\x01r\x02\x04uuid\x04\x04data\x05\
\x04\0\x0cservice-data\x03\0\x06\x01r\x02\x0acompany-id{\x04data\x05\x04\0\x11ma\
nufacturer-data\x03\0\x08\x01r\x02\x0cmin-interval{\x0cmax-interval{\x04\0\x16ad\
vertisement-interval\x03\0\x0a\x01p\x04\x01p\x07\x01k{\x01k\x09\x01r\x05\x10incl\
ude-tx-power\x7f\x05uuids\x0c\x0cservice-data\x0d\x0aappearance\x0e\x11manufactu\
rer-data\x0f\x04\0\x0cencoded-data\x03\0\x10\x01@\0\0\x01\x04\0\x0fget-ble-versi\
on\x01\x12\x01j\0\0\x01@\x01\x08interval\x0b\0\x13\x04\0\x20configure-advertisem\
ent-interval\x01\x14\x01@\x01\x04data\x11\0\x13\x04\0\x16set-advertisement-data\x01\
\x15\x01@\x01\x04data\x05\0\x13\x04\0\x1aset-advertisement-data-raw\x01\x16\x01@\
\x01\x07disable\x7f\x01\0\x04\0\x1edisable-decoded-advertisements\x01\x17\x03\0\x14\
rudel:base/ble@0.0.1\x05\x03\x02\x03\0\x02\x0cservice-uuid\x02\x03\0\x02\x0cserv\
ice-data\x02\x03\0\x02\x11manufacturer-data\x01B\x1b\x02\x03\x02\x01\x04\x04\0\x0c\
service-uuid\x03\0\0\x02\x03\x02\x01\x05\x04\0\x0cservice-data\x03\0\x02\x02\x03\
\x02\x01\x06\x04\0\x11manufacturer-data\x03\0\x04\x01n\x05\x14limited-discoverab\
le\x14general-discoverable\x14br-edr-not-supported\x17simultaneous-controller\x11\
simultaneous-host\x04\0\x13advertisement-flags\x03\0\x06\x01m\x05\x08indirect\x0a\
direct-ind\x0dindirect-scan\x18indirect-not-connectable\x0dscan-response\x04\0\x12\
advertisement-type\x03\0\x08\x01ks\x01k}\x01p\x01\x01p\x03\x01k{\x01k\x05\x01r\x07\
\x04name\x0a\x13advertisement-flags\x07\x08tx-power\x0b\x05uuids\x0c\x0cservice-\
data\x0d\x0aappearance\x0e\x11manufacturer-data\x0f\x04\0\x0cdecoded-data\x03\0\x10\
\x01p}\x01q\x02\x07decoded\x01\x11\0\x03raw\x01\x12\0\x04\0\x12advertisement-dat\
a\x03\0\x13\x01r\x05\x0breceived-atw\x07addressw\x04rssi~\x12advertisement-type\x09\
\x04data\x14\x04\0\x0dadvertisement\x03\0\x15\x01q\x01\x0dadvertisement\x01\x16\0\
\x04\0\x09ble-event\x03\0\x17\x01@\x01\x05event\x18\x01\0\x04\0\x08on-event\x01\x19\
\x04\0\x1arudel:base/ble-guest@0.0.1\x05\x07\x01B\x02\x01@\0\x01\0\x04\0\x03run\x01\
\0\x04\0\x14rudel:base/run@0.0.1\x05\x08\x04\0\x16rudel:base/rudel@0.0.1\x04\0\x0b\
\x0b\x01\0\x05rudel\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-compo\
nent\x070.220.0\x10wit-bindgen-rust\x060.36.0";
        };
    };
}
#[doc(inline)]
pub use __export_rudel_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel-with-all-of-its-exports-removed:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1674] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xee\x0b\x01A\x02\x01\
A\x07\x01B\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\
\0\x09yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06\
microsw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05\
level\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\
\0\x0a\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x03\
\0\x15rudel:base/base@0.0.1\x05\0\x02\x03\0\0\x10semantic-version\x01B\x1f\x02\x03\
\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x03\x03red}\x05green}\x04blu\
e}\x04\0\x09led-color\x03\0\x02\x01r\x02\x05color\x03\x07max-lux{\x04\0\x08led-i\
nfo\x03\0\x04\x01m\x02\x04none\x05basic\x04\0\x12ambient-light-type\x03\0\x06\x01\
m\x02\x04none\x04ball\x04\0\x15vibration-sensor-type\x03\0\x08\x01m\x02\x04none\x05\
basic\x04\0\x13voltage-sensor-type\x03\0\x0a\x01@\0\0\x01\x04\0\x14get-hardware-\
version\x01\x0c\x01p{\x01@\x02\x08first-id{\x03lux\x0d\0y\x04\0\x08set-leds\x01\x0e\
\x01@\x02\x05color\x03\x03luxy\0y\x04\0\x07set-rgb\x01\x0f\x01@\0\0y\x04\0\x09le\
d-count\x01\x10\x01@\x01\x02id{\0\x05\x04\0\x0cget-led-info\x01\x11\x01@\0\0\x07\
\x04\0\x16get-ambient-light-type\x01\x12\x04\0\x11get-ambient-light\x01\x10\x01@\
\0\0\x09\x04\0\x19get-vibration-sensor-type\x01\x13\x04\0\x0dget-vibration\x01\x10\
\x04\0\x17get-voltage-sensor-type\x01\x13\x04\0\x0bget-voltage\x01\x10\x03\0\x19\
rudel:base/hardware@0.0.1\x05\x02\x01B\x1d\x02\x03\x02\x01\x01\x04\0\x10semantic\
-version\x03\0\0\x01o\x02ww\x01q\x03\x06uuid16\x01{\0\x06uuid32\x01y\0\x07uuid12\
8\x01\x02\0\x04\0\x0cservice-uuid\x03\0\x03\x01p}\x01r\x02\x04uuid\x04\x04data\x05\
\x04\0\x0cservice-data\x03\0\x06\x01r\x02\x0acompany-id{\x04data\x05\x04\0\x11ma\
nufacturer-data\x03\0\x08\x01r\x02\x0cmin-interval{\x0cmax-interval{\x04\0\x16ad\
vertisement-interval\x03\0\x0a\x01p\x04\x01p\x07\x01k{\x01k\x09\x01r\x05\x10incl\
ude-tx-power\x7f\x05uuids\x0c\x0cservice-data\x0d\x0aappearance\x0e\x11manufactu\
rer-data\x0f\x04\0\x0cencoded-data\x03\0\x10\x01@\0\0\x01\x04\0\x0fget-ble-versi\
on\x01\x12\x01j\0\0\x01@\x01\x08interval\x0b\0\x13\x04\0\x20configure-advertisem\
ent-interval\x01\x14\x01@\x01\x04data\x11\0\x13\x04\0\x16set-advertisement-data\x01\
\x15\x01@\x01\x04data\x05\0\x13\x04\0\x1aset-advertisement-data-raw\x01\x16\x01@\
\x01\x07disable\x7f\x01\0\x04\0\x1edisable-decoded-advertisements\x01\x17\x03\0\x14\
rudel:base/ble@0.0.1\x05\x03\x04\06rudel:base/rudel-with-all-of-its-exports-remo\
ved@0.0.1\x04\0\x0b+\x01\0%rudel-with-all-of-its-exports-removed\x03\0\0\0G\x09p\
roducers\x01\x0cprocessed-by\x02\x0dwit-component\x070.220.0\x10wit-bindgen-rust\
\x060.36.0";
