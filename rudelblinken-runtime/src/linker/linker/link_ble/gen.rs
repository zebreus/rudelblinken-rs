// // Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// // Options used:
// //   * bitflags_path: "bitflags"
// //   * disable_custom_section_link_helpers
// #[rustfmt::skip]
// #[allow(dead_code, clippy::all)]
// pub mod rudel {
//     pub mod base {
//         /// base is the interface for all basic functionality of the rudelblinken system
//         #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
//         pub mod base {
//             use super::super::super::_rt;
//             /// The semantic version of a module
//             #[repr(C)]
//             #[derive(Clone, Copy)]
//             pub struct SemanticVersion {
//                 pub major: u8,
//                 pub minor: u8,
//                 pub patch: u8,
//             }
//             impl ::core::fmt::Debug for SemanticVersion {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("SemanticVersion")
//                         .field("major", &self.major)
//                         .field("minor", &self.minor)
//                         .field("patch", &self.patch)
//                         .finish()
//                 }
//             }
//             /// Level of a log entry
//             #[repr(u8)]
//             #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
//             pub enum LogLevel {
//                 Error,
//                 Warning,
//                 Info,
//                 Debug,
//                 Trace,
//             }
//             impl ::core::fmt::Debug for LogLevel {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     match self {
//                         LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
//                         LogLevel::Warning => f.debug_tuple("LogLevel::Warning").finish(),
//                         LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
//                         LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
//                         LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
//                     }
//                 }
//             }
//             impl LogLevel {
//                 #[doc(hidden)]
//                 pub unsafe fn _lift(val: u8) -> LogLevel {
//                     if !cfg!(debug_assertions) {
//                         return ::core::mem::transmute(val);
//                     }
//                     match val {
//                         0 => LogLevel::Error,
//                         1 => LogLevel::Warning,
//                         2 => LogLevel::Info,
//                         3 => LogLevel::Debug,
//                         4 => LogLevel::Trace,
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Get the version of the rudel base
//             ///
//             /// If your module requests newer versions of the modules than the host implements, it will attempt to link its old ones anyways and make them conforme to the requested signatures. You can use this function to get the actual version of the host functions.
//             ///
//             /// If your module requests older versions of the host modules, the host will link compatible functions if available, or abort during linking.
//             ///
//             /// The host will mock out all functions it can not link.
//             pub fn get_base_version() -> SemanticVersion {
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
//                     let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
//                     let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "get-base-version"]
//                         fn wit_import1(_: *mut u8);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: *mut u8) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import1(ptr0) };
//                     let l2 = i32::from(*ptr0.add(0).cast::<u8>());
//                     let l3 = i32::from(*ptr0.add(1).cast::<u8>());
//                     let l4 = i32::from(*ptr0.add(2).cast::<u8>());
//                     let result5 = SemanticVersion {
//                         major: l2 as u8,
//                         minor: l3 as u8,
//                         patch: l4 as u8,
//                     };
//                     result5
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// You need to yield periodically, as the watchdog will kill you if you dont
//             ///
//             /// Will try to sleep for the given duration while still serving callbacks
//             ///
//             /// Use micros = 0 to sleep for the minimum duration
//             ///
//             /// Returns the new fuel amount
//             pub fn yield_now(micros: u64) -> u32 {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "yield-now"]
//                         fn wit_import0(_: i64) -> i32;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0(_: i64) -> i32 {
//                         unreachable!()
//                     }
//                     let ret = unsafe { wit_import0(_rt::as_i64(&micros)) };
//                     ret as u32
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Get the remaining fuel
//             pub fn get_remaining_fuel() -> u32 {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "get-remaining-fuel"]
//                         fn wit_import0() -> i32;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0() -> i32 {
//                         unreachable!()
//                     }
//                     let ret = unsafe { wit_import0() };
//                     ret as u32
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Sleep for a given amount of time without yielding
//             pub fn sleep(micros: u64) -> () {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "sleep"]
//                         fn wit_import0(_: i64);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0(_: i64) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import0(_rt::as_i64(&micros)) };
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Returns the number of microseconds that have passed since boot
//             pub fn time() -> u64 {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "time"]
//                         fn wit_import0() -> i64;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0() -> i64 {
//                         unreachable!()
//                     }
//                     let ret = unsafe { wit_import0() };
//                     ret as u64
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Log a message
//             pub fn log(level: LogLevel, message: &str) -> () {
//                 unsafe {
//                     let vec0 = message;
//                     let ptr0 = vec0.as_ptr().cast::<u8>();
//                     let len0 = vec0.len();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "log"]
//                         fn wit_import1(_: i32, _: *mut u8, _: usize);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import1(level.clone() as i32, ptr0.cast_mut(), len0) };
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// The name of this host. It is guaranteed to be unique, and will not change during the lifetime of the host.
//             ///
//             /// The name is returned as a list of 16 bytes to avoid the need for allocations on the host side, as the buffer will be allocated by the guest. The name is UTF-8 encoded, and the buffer will be zero padded after the end of the string.
//             ///
//             /// Once fixed size lists gets stabilized in WIT, this will be changed to a list<u8, 16>. That should not affect the ABI as the representation of a tuple and a fixed size list is the same.
//             ///
//             /// Your host bindings should provide a wrapper for this that converts the list to a string.
//             pub fn get_name() -> (
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//                 u8,
//             ) {
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
//                     let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
//                     let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "get-name"]
//                         fn wit_import1(_: *mut u8);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: *mut u8) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import1(ptr0) };
//                     let l2 = i32::from(*ptr0.add(0).cast::<u8>());
//                     let l3 = i32::from(*ptr0.add(1).cast::<u8>());
//                     let l4 = i32::from(*ptr0.add(2).cast::<u8>());
//                     let l5 = i32::from(*ptr0.add(3).cast::<u8>());
//                     let l6 = i32::from(*ptr0.add(4).cast::<u8>());
//                     let l7 = i32::from(*ptr0.add(5).cast::<u8>());
//                     let l8 = i32::from(*ptr0.add(6).cast::<u8>());
//                     let l9 = i32::from(*ptr0.add(7).cast::<u8>());
//                     let l10 = i32::from(*ptr0.add(8).cast::<u8>());
//                     let l11 = i32::from(*ptr0.add(9).cast::<u8>());
//                     let l12 = i32::from(*ptr0.add(10).cast::<u8>());
//                     let l13 = i32::from(*ptr0.add(11).cast::<u8>());
//                     let l14 = i32::from(*ptr0.add(12).cast::<u8>());
//                     let l15 = i32::from(*ptr0.add(13).cast::<u8>());
//                     let l16 = i32::from(*ptr0.add(14).cast::<u8>());
//                     let l17 = i32::from(*ptr0.add(15).cast::<u8>());
//                     let result18 = (
//                         l2 as u8,
//                         l3 as u8,
//                         l4 as u8,
//                         l5 as u8,
//                         l6 as u8,
//                         l7 as u8,
//                         l8 as u8,
//                         l9 as u8,
//                         l10 as u8,
//                         l11 as u8,
//                         l12 as u8,
//                         l13 as u8,
//                         l14 as u8,
//                         l15 as u8,
//                         l16 as u8,
//                         l17 as u8,
//                     );
//                     result18
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Returns the configuration for this guest, as configured over BLE. The
//             /// semantics of the configuration depend on the guest.
//             pub fn get_config() -> _rt::Vec<u8> {
//                 unsafe {
//                     #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
//                     #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
//                     struct RetArea(
//                         [::core::mem::MaybeUninit<
//                             u8,
//                         >; 2 * ::core::mem::size_of::<*const u8>()],
//                     );
//                     let mut ret_area = RetArea(
//                         [::core::mem::MaybeUninit::uninit(); 2
//                             * ::core::mem::size_of::<*const u8>()],
//                     );
//                     let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/base@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "get-config"]
//                         fn wit_import1(_: *mut u8);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: *mut u8) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import1(ptr0) };
//                     let l2 = *ptr0.add(0).cast::<*mut u8>();
//                     let l3 = *ptr0
//                         .add(::core::mem::size_of::<*const u8>())
//                         .cast::<usize>();
//                     let len4 = l3;
//                     let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
//                     result5
//                 }
//             }
//         }
//         /// Control ble stuff
//         #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
//         pub mod ble {
//             use super::super::super::_rt;
//             pub type SemanticVersion = super::super::super::rudel::base::base::SemanticVersion;
//             /// A service UUID, can be a shortened one
//             #[derive(Clone, Copy)]
//             pub enum ServiceUuid {
//                 Uuid16(u16),
//                 Uuid32(u32),
//                 Uuid128((u64, u64)),
//             }
//             impl ::core::fmt::Debug for ServiceUuid {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     match self {
//                         ServiceUuid::Uuid16(e) => {
//                             f.debug_tuple("ServiceUuid::Uuid16").field(e).finish()
//                         }
//                         ServiceUuid::Uuid32(e) => {
//                             f.debug_tuple("ServiceUuid::Uuid32").field(e).finish()
//                         }
//                         ServiceUuid::Uuid128(e) => {
//                             f.debug_tuple("ServiceUuid::Uuid128").field(e).finish()
//                         }
//                     }
//                 }
//             }
//             /// Service specific data
//             #[derive(Clone)]
//             pub struct ServiceData {
//                 pub uuid: ServiceUuid,
//                 pub data: _rt::Vec<u8>,
//             }
//             impl ::core::fmt::Debug for ServiceData {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("ServiceData")
//                         .field("uuid", &self.uuid)
//                         .field("data", &self.data)
//                         .finish()
//                 }
//             }
//             /// Manufacturer specific data
//             #[derive(Clone)]
//             pub struct ManufacturerData {
//                 pub company_id: u16,
//                 pub data: _rt::Vec<u8>,
//             }
//             impl ::core::fmt::Debug for ManufacturerData {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("ManufacturerData")
//                         .field("company-id", &self.company_id)
//                         .field("data", &self.data)
//                         .finish()
//                 }
//             }
//             /// Configure the BLE advertisements
//             #[repr(C)]
//             #[derive(Clone, Copy)]
//             pub struct AdvertisementInterval {
//                 pub min_interval: u16,
//                 pub max_interval: u16,
//             }
//             impl ::core::fmt::Debug for AdvertisementInterval {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("AdvertisementInterval")
//                         .field("min-interval", &self.min_interval)
//                         .field("max-interval", &self.max_interval)
//                         .finish()
//                 }
//             }
//             /// Sendable BLE advertisement data
//             ///
//             /// Can be at most 31 bytes - (size of the name + 6 bytes)
//             #[derive(Clone)]
//             pub struct EncodedData {
//                 /// Include the transmission power. (3 bytes)
//                 pub include_tx_power: bool,
//                 /// service UUIDs (2 bytes per used class (16, 32, 128 bit UUID) + size of the UUIDs)
//                 pub uuids: _rt::Vec<ServiceUuid>,
//                 /// service data (2 byte + size of the UUID + size of data) for each service data)
//                 pub service_data: _rt::Vec<ServiceData>,
//                 /// appearance (4 byte)
//                 pub appearance: Option<u16>,
//                 /// manufacturer specific data (2 byte + 2 byte company ID + size of data)
//                 pub manufacturer_data: Option<ManufacturerData>,
//             }
//             impl ::core::fmt::Debug for EncodedData {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("EncodedData")
//                         .field("include-tx-power", &self.include_tx_power)
//                         .field("uuids", &self.uuids)
//                         .field("service-data", &self.service_data)
//                         .field("appearance", &self.appearance)
//                         .field("manufacturer-data", &self.manufacturer_data)
//                         .finish()
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Get the version of the hardware interface provided by the runtime.
//             ///
//             /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
//             pub fn get_ble_version() -> SemanticVersion {
//                 unsafe {
//                     #[repr(align(1))]
//                     struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
//                     let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
//                     let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "get-ble-version"]
//                         fn wit_import1(_: *mut u8);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: *mut u8) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import1(ptr0) };
//                     let l2 = i32::from(*ptr0.add(0).cast::<u8>());
//                     let l3 = i32::from(*ptr0.add(1).cast::<u8>());
//                     let l4 = i32::from(*ptr0.add(2).cast::<u8>());
//                     let result5 = super::super::super::rudel::base::base::SemanticVersion {
//                         major: l2 as u8,
//                         minor: l3 as u8,
//                         patch: l4 as u8,
//                     };
//                     result5
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Configure the interval in which BLE advertisements are sent
//             ///
//             /// Returns an error if the interval is not valid
//             pub fn configure_advertisement_interval(
//                 interval: AdvertisementInterval,
//             ) -> Result<(), ()> {
//                 unsafe {
//                     let AdvertisementInterval {
//                         min_interval: min_interval0,
//                         max_interval: max_interval0,
//                     } = interval;
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "configure-advertisement-interval"]
//                         fn wit_import1(_: i32, _: i32) -> i32;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: i32, _: i32) -> i32 {
//                         unreachable!()
//                     }
//                     let ret = unsafe {
//                         wit_import1(
//                             _rt::as_i32(min_interval0),
//                             _rt::as_i32(max_interval0),
//                         )
//                     };
//                     match ret {
//                         0 => {
//                             let e = ();
//                             Ok(e)
//                         }
//                         1 => {
//                             let e = ();
//                             Err(e)
//                         }
//                         _ => _rt::invalid_enum_discriminant(),
//                     }
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Set the advertisement data. The device name will also be added to the advertisement.
//             ///
//             /// If you need more control use set-advertisement-data-raw
//             ///
//             /// Will fail if your data is too long
//             pub fn set_advertisement_data(data: &EncodedData) -> Result<(), ()> {
//                 unsafe {
//                     let EncodedData {
//                         include_tx_power: include_tx_power0,
//                         uuids: uuids0,
//                         service_data: service_data0,
//                         appearance: appearance0,
//                         manufacturer_data: manufacturer_data0,
//                     } = data;
//                     let vec2 = uuids0;
//                     let len2 = vec2.len();
//                     let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
//                         vec2.len() * 24,
//                         8,
//                     );
//                     let result2 = if layout2.size() != 0 {
//                         let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
//                         if ptr.is_null() {
//                             _rt::alloc::handle_alloc_error(layout2);
//                         }
//                         ptr
//                     } else {
//                         ::core::ptr::null_mut()
//                     };
//                     for (i, e) in vec2.into_iter().enumerate() {
//                         let base = result2.add(i * 24);
//                         {
//                             match e {
//                                 ServiceUuid::Uuid16(e) => {
//                                     *base.add(0).cast::<u8>() = (0i32) as u8;
//                                     *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
//                                 }
//                                 ServiceUuid::Uuid32(e) => {
//                                     *base.add(0).cast::<u8>() = (1i32) as u8;
//                                     *base.add(8).cast::<i32>() = _rt::as_i32(e);
//                                 }
//                                 ServiceUuid::Uuid128(e) => {
//                                     *base.add(0).cast::<u8>() = (2i32) as u8;
//                                     let (t1_0, t1_1) = e;
//                                     *base.add(8).cast::<i64>() = _rt::as_i64(t1_0);
//                                     *base.add(16).cast::<i64>() = _rt::as_i64(t1_1);
//                                 }
//                             }
//                         }
//                     }
//                     let vec6 = service_data0;
//                     let len6 = vec6.len();
//                     let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
//                         vec6.len() * (24 + 2 * ::core::mem::size_of::<*const u8>()),
//                         8,
//                     );
//                     let result6 = if layout6.size() != 0 {
//                         let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
//                         if ptr.is_null() {
//                             _rt::alloc::handle_alloc_error(layout6);
//                         }
//                         ptr
//                     } else {
//                         ::core::ptr::null_mut()
//                     };
//                     for (i, e) in vec6.into_iter().enumerate() {
//                         let base = result6
//                             .add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
//                         {
//                             let ServiceData { uuid: uuid3, data: data3 } = e;
//                             match uuid3 {
//                                 ServiceUuid::Uuid16(e) => {
//                                     *base.add(0).cast::<u8>() = (0i32) as u8;
//                                     *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
//                                 }
//                                 ServiceUuid::Uuid32(e) => {
//                                     *base.add(0).cast::<u8>() = (1i32) as u8;
//                                     *base.add(8).cast::<i32>() = _rt::as_i32(e);
//                                 }
//                                 ServiceUuid::Uuid128(e) => {
//                                     *base.add(0).cast::<u8>() = (2i32) as u8;
//                                     let (t4_0, t4_1) = e;
//                                     *base.add(8).cast::<i64>() = _rt::as_i64(t4_0);
//                                     *base.add(16).cast::<i64>() = _rt::as_i64(t4_1);
//                                 }
//                             }
//                             let vec5 = data3;
//                             let ptr5 = vec5.as_ptr().cast::<u8>();
//                             let len5 = vec5.len();
//                             *base
//                                 .add(24 + 1 * ::core::mem::size_of::<*const u8>())
//                                 .cast::<usize>() = len5;
//                             *base.add(24).cast::<*mut u8>() = ptr5.cast_mut();
//                         }
//                     }
//                     let (result7_0, result7_1) = match appearance0 {
//                         Some(e) => (1i32, _rt::as_i32(e)),
//                         None => (0i32, 0i32),
//                     };
//                     let (result10_0, result10_1, result10_2, result10_3) = match manufacturer_data0 {
//                         Some(e) => {
//                             let ManufacturerData {
//                                 company_id: company_id8,
//                                 data: data8,
//                             } = e;
//                             let vec9 = data8;
//                             let ptr9 = vec9.as_ptr().cast::<u8>();
//                             let len9 = vec9.len();
//                             (1i32, _rt::as_i32(company_id8), ptr9.cast_mut(), len9)
//                         }
//                         None => (0i32, 0i32, ::core::ptr::null_mut(), 0usize),
//                     };
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "set-advertisement-data"]
//                         fn wit_import11(
//                             _: i32,
//                             _: *mut u8,
//                             _: usize,
//                             _: *mut u8,
//                             _: usize,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: i32,
//                             _: *mut u8,
//                             _: usize,
//                         ) -> i32;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import11(
//                         _: i32,
//                         _: *mut u8,
//                         _: usize,
//                         _: *mut u8,
//                         _: usize,
//                         _: i32,
//                         _: i32,
//                         _: i32,
//                         _: i32,
//                         _: *mut u8,
//                         _: usize,
//                     ) -> i32 {
//                         unreachable!()
//                     }
//                     let ret = unsafe {
//                         wit_import11(
//                             match include_tx_power0 {
//                                 true => 1,
//                                 false => 0,
//                             },
//                             result2,
//                             len2,
//                             result6,
//                             len6,
//                             result7_0,
//                             result7_1,
//                             result10_0,
//                             result10_1,
//                             result10_2,
//                             result10_3,
//                         )
//                     };
//                     if layout2.size() != 0 {
//                         _rt::alloc::dealloc(result2.cast(), layout2);
//                     }
//                     if layout6.size() != 0 {
//                         _rt::alloc::dealloc(result6.cast(), layout6);
//                     }
//                     match ret {
//                         0 => {
//                             let e = ();
//                             Ok(e)
//                         }
//                         1 => {
//                             let e = ();
//                             Err(e)
//                         }
//                         _ => _rt::invalid_enum_discriminant(),
//                     }
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Set the raw advertisement data. There will be no additional properties added.
//             ///
//             /// Can be at most 31 bytes
//             ///
//             /// Will fail if your data is too long
//             pub fn set_advertisement_data_raw(data: &[u8]) -> Result<(), ()> {
//                 unsafe {
//                     let vec0 = data;
//                     let ptr0 = vec0.as_ptr().cast::<u8>();
//                     let len0 = vec0.len();
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "set-advertisement-data-raw"]
//                         fn wit_import1(_: *mut u8, _: usize) -> i32;
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) -> i32 {
//                         unreachable!()
//                     }
//                     let ret = unsafe { wit_import1(ptr0.cast_mut(), len0) };
//                     match ret {
//                         0 => {
//                             let e = ();
//                             Ok(e)
//                         }
//                         1 => {
//                             let e = ();
//                             Err(e)
//                         }
//                         _ => _rt::invalid_enum_discriminant(),
//                     }
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Disable decoded advertisements
//             ///
//             /// true => `on-event` will only receive raw advertisements
//             /// false => `on-event` will decode advertisements, if possible
//             pub fn disable_decoded_advertisements(disable: bool) -> () {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "disable-decoded-advertisements"]
//                         fn wit_import0(_: i32);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0(_: i32) {
//                         unreachable!()
//                     }
//                     unsafe {
//                         wit_import0(
//                             match &disable {
//                                 true => 1,
//                                 false => 0,
//                             },
//                         )
//                     };
//                 }
//             }
//         }
//         #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
//         pub mod ble_guest {
//             use super::super::super::_rt;
//             pub type ServiceUuid = super::super::super::rudel::base::ble::ServiceUuid;
//             pub type ServiceData = super::super::super::rudel::base::ble::ServiceData;
//             pub type ManufacturerData = super::super::super::rudel::base::ble::ManufacturerData;
//             bitflags::bitflags! {
//                 #[doc = " TODO: Check order"] #[derive(PartialEq, Eq, PartialOrd, Ord,
//                 Hash, Debug, Clone, Copy)] pub struct AdvertisementFlags : u8 { #[doc =
//                 " LE Limited Discoverable Mode"] const LIMITED_DISCOVERABLE = 1 << 0;
//                 #[doc = " LE General Discoverable Mode"] const GENERAL_DISCOVERABLE = 1
//                 << 1; #[doc = " BR/EDR Not Supported"] const BR_EDR_NOT_SUPPORTED = 1 <<
//                 2; #[doc =
//                 " Simultaneous LE and BR/EDR to Same Device Capable (Controller)"] const
//                 SIMULTANEOUS_CONTROLLER = 1 << 3; #[doc =
//                 " Simultaneous LE and BR/EDR to Same Device Capable (Host)"] const
//                 SIMULTANEOUS_HOST = 1 << 4; }
//             }
//             #[repr(u8)]
//             #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
//             pub enum AdvertisementType {
//                 /// indirect advertising
//                 Indirect,
//                 /// direct advertising
//                 DirectInd,
//                 /// indirect scan response
//                 IndirectScan,
//                 /// indirect advertising - not connectable
//                 IndirectNotConnectable,
//                 /// scan responst
//                 ScanResponse,
//             }
//             impl ::core::fmt::Debug for AdvertisementType {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     match self {
//                         AdvertisementType::Indirect => {
//                             f.debug_tuple("AdvertisementType::Indirect").finish()
//                         }
//                         AdvertisementType::DirectInd => {
//                             f.debug_tuple("AdvertisementType::DirectInd").finish()
//                         }
//                         AdvertisementType::IndirectScan => {
//                             f.debug_tuple("AdvertisementType::IndirectScan").finish()
//                         }
//                         AdvertisementType::IndirectNotConnectable => {
//                             f.debug_tuple("AdvertisementType::IndirectNotConnectable")
//                                 .finish()
//                         }
//                         AdvertisementType::ScanResponse => {
//                             f.debug_tuple("AdvertisementType::ScanResponse").finish()
//                         }
//                     }
//                 }
//             }
//             impl AdvertisementType {
//                 #[doc(hidden)]
//                 pub unsafe fn _lift(val: u8) -> AdvertisementType {
//                     if !cfg!(debug_assertions) {
//                         return ::core::mem::transmute(val);
//                     }
//                     match val {
//                         0 => AdvertisementType::Indirect,
//                         1 => AdvertisementType::DirectInd,
//                         2 => AdvertisementType::IndirectScan,
//                         3 => AdvertisementType::IndirectNotConnectable,
//                         4 => AdvertisementType::ScanResponse,
//                         _ => panic!("invalid enum discriminant"),
//                     }
//                 }
//             }
//             /// Decoded BLE advertisement
//             #[derive(Clone)]
//             pub struct DecodedData {
//                 /// name of the remote device
//                 pub name: Option<_rt::String>,
//                 /// flags
//                 pub advertisement_flags: AdvertisementFlags,
//                 /// tx power
//                 pub tx_power: Option<u8>,
//                 /// service UUIDs
//                 pub uuids: _rt::Vec<ServiceUuid>,
//                 /// service data
//                 pub service_data: _rt::Vec<ServiceData>,
//                 /// appearance
//                 pub appearance: Option<u16>,
//                 /// manufacturer specific data
//                 pub manufacturer_data: Option<ManufacturerData>,
//             }
//             impl ::core::fmt::Debug for DecodedData {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("DecodedData")
//                         .field("name", &self.name)
//                         .field("advertisement-flags", &self.advertisement_flags)
//                         .field("tx-power", &self.tx_power)
//                         .field("uuids", &self.uuids)
//                         .field("service-data", &self.service_data)
//                         .field("appearance", &self.appearance)
//                         .field("manufacturer-data", &self.manufacturer_data)
//                         .finish()
//                 }
//             }
//             #[derive(Clone)]
//             pub enum AdvertisementData {
//                 /// Decoded advertisement data
//                 Decoded(DecodedData),
//                 /// Raw advertisement data. Returned if there were some fields that failed decoding
//                 Raw(_rt::Vec<u8>),
//             }
//             impl ::core::fmt::Debug for AdvertisementData {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     match self {
//                         AdvertisementData::Decoded(e) => {
//                             f.debug_tuple("AdvertisementData::Decoded").field(e).finish()
//                         }
//                         AdvertisementData::Raw(e) => {
//                             f.debug_tuple("AdvertisementData::Raw").field(e).finish()
//                         }
//                     }
//                 }
//             }
//             /// Decoded BLE advertisement
//             #[derive(Clone)]
//             pub struct Advertisement {
//                 /// When the advertisement was received
//                 /// There may be some delay between when the advertisement was received and when the WASM guest is notified
//                 pub received_at: u64,
//                 /// The address of the sender 48bit integer
//                 pub address: u64,
//                 /// Received signal strength
//                 pub rssi: i8,
//                 /// Received advertisement type
//                 pub advertisement_type: AdvertisementType,
//                 /// Received data
//                 /// Will be decoded if it can be decoded
//                 pub data: AdvertisementData,
//             }
//             impl ::core::fmt::Debug for Advertisement {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     f.debug_struct("Advertisement")
//                         .field("received-at", &self.received_at)
//                         .field("address", &self.address)
//                         .field("rssi", &self.rssi)
//                         .field("advertisement-type", &self.advertisement_type)
//                         .field("data", &self.data)
//                         .finish()
//                 }
//             }
//             /// A ble event
//             /// For now only advertisements
//             #[derive(Clone)]
//             pub enum BleEvent {
//                 Advertisement(Advertisement),
//             }
//             impl ::core::fmt::Debug for BleEvent {
//                 fn fmt(
//                     &self,
//                     f: &mut ::core::fmt::Formatter<'_>,
//                 ) -> ::core::fmt::Result {
//                     match self {
//                         BleEvent::Advertisement(e) => {
//                             f.debug_tuple("BleEvent::Advertisement").field(e).finish()
//                         }
//                     }
//                 }
//             }
//             #[allow(unused_unsafe, clippy::all)]
//             /// Check if the ble module is implemented
//             ///
//             /// The rudelblinken runtime will mock out all functions the it can not link.
//             /// If this function returns false you should not use any of the other functions
//             pub fn on_event(event: &BleEvent) -> () {
//                 unsafe {
//                     let mut cleanup_list = _rt::Vec::new();
//                     #[repr(align(8))]
//                     struct RetArea(
//                         [::core::mem::MaybeUninit<
//                             u8,
//                         >; 32 + 14 * ::core::mem::size_of::<*const u8>()],
//                     );
//                     let mut ret_area = RetArea(
//                         [::core::mem::MaybeUninit::uninit(); 32
//                             + 14 * ::core::mem::size_of::<*const u8>()],
//                     );
//                     let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
//                     match event {
//                         BleEvent::Advertisement(e) => {
//                             *ptr0.add(0).cast::<u8>() = (0i32) as u8;
//                             let Advertisement {
//                                 received_at: received_at1,
//                                 address: address1,
//                                 rssi: rssi1,
//                                 advertisement_type: advertisement_type1,
//                                 data: data1,
//                             } = e;
//                             *ptr0.add(8).cast::<i64>() = _rt::as_i64(received_at1);
//                             *ptr0.add(16).cast::<i64>() = _rt::as_i64(address1);
//                             *ptr0.add(24).cast::<u8>() = (_rt::as_i32(rssi1)) as u8;
//                             *ptr0.add(25).cast::<u8>() = (advertisement_type1.clone()
//                                 as i32) as u8;
//                             match data1 {
//                                 AdvertisementData::Decoded(e) => {
//                                     *ptr0
//                                         .add(24 + 1 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<u8>() = (0i32) as u8;
//                                     let DecodedData {
//                                         name: name2,
//                                         advertisement_flags: advertisement_flags2,
//                                         tx_power: tx_power2,
//                                         uuids: uuids2,
//                                         service_data: service_data2,
//                                         appearance: appearance2,
//                                         manufacturer_data: manufacturer_data2,
//                                     } = e;
//                                     match name2 {
//                                         Some(e) => {
//                                             *ptr0
//                                                 .add(24 + 2 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (1i32) as u8;
//                                             let vec3 = e;
//                                             let ptr3 = vec3.as_ptr().cast::<u8>();
//                                             let len3 = vec3.len();
//                                             *ptr0
//                                                 .add(24 + 4 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<usize>() = len3;
//                                             *ptr0
//                                                 .add(24 + 3 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<*mut u8>() = ptr3.cast_mut();
//                                         }
//                                         None => {
//                                             *ptr0
//                                                 .add(24 + 2 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (0i32) as u8;
//                                         }
//                                     };
//                                     let flags4 = advertisement_flags2;
//                                     *ptr0
//                                         .add(24 + 5 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<u8>() = ((flags4.bits() >> 0) as i32) as u8;
//                                     match tx_power2 {
//                                         Some(e) => {
//                                             *ptr0
//                                                 .add(25 + 5 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (1i32) as u8;
//                                             *ptr0
//                                                 .add(26 + 5 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (_rt::as_i32(e)) as u8;
//                                         }
//                                         None => {
//                                             *ptr0
//                                                 .add(25 + 5 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (0i32) as u8;
//                                         }
//                                     };
//                                     let vec7 = uuids2;
//                                     let len7 = vec7.len();
//                                     let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
//                                         vec7.len() * 24,
//                                         8,
//                                     );
//                                     let result7 = if layout7.size() != 0 {
//                                         let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
//                                         if ptr.is_null() {
//                                             _rt::alloc::handle_alloc_error(layout7);
//                                         }
//                                         ptr
//                                     } else {
//                                         ::core::ptr::null_mut()
//                                     };
//                                     for (i, e) in vec7.into_iter().enumerate() {
//                                         let base = result7.add(i * 24);
//                                         {
//                                             use super::super::super::rudel::base::ble::ServiceUuid as V6;
//                                             match e {
//                                                 V6::Uuid16(e) => {
//                                                     *base.add(0).cast::<u8>() = (0i32) as u8;
//                                                     *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
//                                                 }
//                                                 V6::Uuid32(e) => {
//                                                     *base.add(0).cast::<u8>() = (1i32) as u8;
//                                                     *base.add(8).cast::<i32>() = _rt::as_i32(e);
//                                                 }
//                                                 V6::Uuid128(e) => {
//                                                     *base.add(0).cast::<u8>() = (2i32) as u8;
//                                                     let (t5_0, t5_1) = e;
//                                                     *base.add(8).cast::<i64>() = _rt::as_i64(t5_0);
//                                                     *base.add(16).cast::<i64>() = _rt::as_i64(t5_1);
//                                                 }
//                                             }
//                                         }
//                                     }
//                                     *ptr0
//                                         .add(24 + 7 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<usize>() = len7;
//                                     *ptr0
//                                         .add(24 + 6 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<*mut u8>() = result7;
//                                     let vec12 = service_data2;
//                                     let len12 = vec12.len();
//                                     let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
//                                         vec12.len()
//                                             * (24 + 2 * ::core::mem::size_of::<*const u8>()),
//                                         8,
//                                     );
//                                     let result12 = if layout12.size() != 0 {
//                                         let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
//                                         if ptr.is_null() {
//                                             _rt::alloc::handle_alloc_error(layout12);
//                                         }
//                                         ptr
//                                     } else {
//                                         ::core::ptr::null_mut()
//                                     };
//                                     for (i, e) in vec12.into_iter().enumerate() {
//                                         let base = result12
//                                             .add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
//                                         {
//                                             let super::super::super::rudel::base::ble::ServiceData {
//                                                 uuid: uuid8,
//                                                 data: data8,
//                                             } = e;
//                                             use super::super::super::rudel::base::ble::ServiceUuid as V10;
//                                             match uuid8 {
//                                                 V10::Uuid16(e) => {
//                                                     *base.add(0).cast::<u8>() = (0i32) as u8;
//                                                     *base.add(8).cast::<u16>() = (_rt::as_i32(e)) as u16;
//                                                 }
//                                                 V10::Uuid32(e) => {
//                                                     *base.add(0).cast::<u8>() = (1i32) as u8;
//                                                     *base.add(8).cast::<i32>() = _rt::as_i32(e);
//                                                 }
//                                                 V10::Uuid128(e) => {
//                                                     *base.add(0).cast::<u8>() = (2i32) as u8;
//                                                     let (t9_0, t9_1) = e;
//                                                     *base.add(8).cast::<i64>() = _rt::as_i64(t9_0);
//                                                     *base.add(16).cast::<i64>() = _rt::as_i64(t9_1);
//                                                 }
//                                             }
//                                             let vec11 = data8;
//                                             let ptr11 = vec11.as_ptr().cast::<u8>();
//                                             let len11 = vec11.len();
//                                             *base
//                                                 .add(24 + 1 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<usize>() = len11;
//                                             *base.add(24).cast::<*mut u8>() = ptr11.cast_mut();
//                                         }
//                                     }
//                                     *ptr0
//                                         .add(24 + 9 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<usize>() = len12;
//                                     *ptr0
//                                         .add(24 + 8 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<*mut u8>() = result12;
//                                     match appearance2 {
//                                         Some(e) => {
//                                             *ptr0
//                                                 .add(24 + 10 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (1i32) as u8;
//                                             *ptr0
//                                                 .add(26 + 10 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u16>() = (_rt::as_i32(e)) as u16;
//                                         }
//                                         None => {
//                                             *ptr0
//                                                 .add(24 + 10 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (0i32) as u8;
//                                         }
//                                     };
//                                     match manufacturer_data2 {
//                                         Some(e) => {
//                                             *ptr0
//                                                 .add(24 + 11 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (1i32) as u8;
//                                             let super::super::super::rudel::base::ble::ManufacturerData {
//                                                 company_id: company_id13,
//                                                 data: data13,
//                                             } = e;
//                                             *ptr0
//                                                 .add(24 + 12 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u16>() = (_rt::as_i32(company_id13)) as u16;
//                                             let vec14 = data13;
//                                             let ptr14 = vec14.as_ptr().cast::<u8>();
//                                             let len14 = vec14.len();
//                                             *ptr0
//                                                 .add(24 + 14 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<usize>() = len14;
//                                             *ptr0
//                                                 .add(24 + 13 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<*mut u8>() = ptr14.cast_mut();
//                                         }
//                                         None => {
//                                             *ptr0
//                                                 .add(24 + 11 * ::core::mem::size_of::<*const u8>())
//                                                 .cast::<u8>() = (0i32) as u8;
//                                         }
//                                     };
//                                     cleanup_list
//                                         .extend_from_slice(
//                                             &[(result7, layout7), (result12, layout12)],
//                                         );
//                                 }
//                                 AdvertisementData::Raw(e) => {
//                                     *ptr0
//                                         .add(24 + 1 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<u8>() = (1i32) as u8;
//                                     let vec15 = e;
//                                     let ptr15 = vec15.as_ptr().cast::<u8>();
//                                     let len15 = vec15.len();
//                                     *ptr0
//                                         .add(24 + 3 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<usize>() = len15;
//                                     *ptr0
//                                         .add(24 + 2 * ::core::mem::size_of::<*const u8>())
//                                         .cast::<*mut u8>() = ptr15.cast_mut();
//                                 }
//                             }
//                         }
//                     }
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/ble-guest@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "on-event"]
//                         fn wit_import16(_: *mut u8);
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import16(_: *mut u8) {
//                         unreachable!()
//                     }
//                     unsafe { wit_import16(ptr0) };
//                     for (ptr, layout) in cleanup_list {
//                         if layout.size() != 0 {
//                             _rt::alloc::dealloc(ptr.cast(), layout);
//                         }
//                     }
//                 }
//             }
//         }
//         #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
//         pub mod run {
//             #[allow(unused_unsafe, clippy::all)]
//             /// Run the program.
//             pub fn run() -> () {
//                 unsafe {
//                     #[cfg(target_arch = "wasm32")]
//                     #[link(wasm_import_module = "rudel:base/run@0.0.1")]
//                     unsafe extern "C" {
//                         #[link_name = "run"]
//                         fn wit_import0();
//                     }
//                     #[cfg(not(target_arch = "wasm32"))]
//                     unsafe extern "C" fn wit_import0() {
//                         unreachable!()
//                     }
//                     unsafe { wit_import0() };
//                 }
//             }
//         }
//     }
// }

#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod rudel {
        pub mod base {
            /// base is the interface for all basic functionality of the rudelblinken system
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod base {
                use super::super::super::super::_rt;
                /// The semantic version of a module
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct SemanticVersion {
                    pub major: u8,
                    pub minor: u8,
                    pub patch: u8,
                }
                impl ::core::fmt::Debug for SemanticVersion {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SemanticVersion")
                            .field("major", &self.major)
                            .field("minor", &self.minor)
                            .field("patch", &self.patch)
                            .finish()
                    }
                }
                /// Level of a log entry
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum LogLevel {
                    Error,
                    Warning,
                    Info,
                    Debug,
                    Trace,
                }
                impl ::core::fmt::Debug for LogLevel {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
                            LogLevel::Warning => {
                                f.debug_tuple("LogLevel::Warning").finish()
                            }
                            LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
                            LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
                            LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
                        }
                    }
                }
                impl LogLevel {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> LogLevel {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => LogLevel::Error,
                            1 => LogLevel::Warning,
                            2 => LogLevel::Info,
                            3 => LogLevel::Debug,
                            4 => LogLevel::Trace,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_base_version_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_base_version();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let SemanticVersion {
                        major: major2,
                        minor: minor2,
                        patch: patch2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(major2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(minor2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(patch2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_yield_now_cabi<T: Guest>(arg0: i64) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::yield_now(arg0 as u64);
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_remaining_fuel_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_remaining_fuel();
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sleep_cabi<T: Guest>(arg0: i64) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::sleep(arg0 as u64);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_time_cabi<T: Guest>() -> i64 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::time();
                    _rt::as_i64(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_log_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    T::log(LogLevel::_lift(arg0 as u8), _rt::string_lift(bytes0));
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_name_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_name();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (
                        t2_0,
                        t2_1,
                        t2_2,
                        t2_3,
                        t2_4,
                        t2_5,
                        t2_6,
                        t2_7,
                        t2_8,
                        t2_9,
                        t2_10,
                        t2_11,
                        t2_12,
                        t2_13,
                        t2_14,
                        t2_15,
                    ) = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(t2_0)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(t2_1)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(t2_2)) as u8;
                    *ptr1.add(3).cast::<u8>() = (_rt::as_i32(t2_3)) as u8;
                    *ptr1.add(4).cast::<u8>() = (_rt::as_i32(t2_4)) as u8;
                    *ptr1.add(5).cast::<u8>() = (_rt::as_i32(t2_5)) as u8;
                    *ptr1.add(6).cast::<u8>() = (_rt::as_i32(t2_6)) as u8;
                    *ptr1.add(7).cast::<u8>() = (_rt::as_i32(t2_7)) as u8;
                    *ptr1.add(8).cast::<u8>() = (_rt::as_i32(t2_8)) as u8;
                    *ptr1.add(9).cast::<u8>() = (_rt::as_i32(t2_9)) as u8;
                    *ptr1.add(10).cast::<u8>() = (_rt::as_i32(t2_10)) as u8;
                    *ptr1.add(11).cast::<u8>() = (_rt::as_i32(t2_11)) as u8;
                    *ptr1.add(12).cast::<u8>() = (_rt::as_i32(t2_12)) as u8;
                    *ptr1.add(13).cast::<u8>() = (_rt::as_i32(t2_13)) as u8;
                    *ptr1.add(14).cast::<u8>() = (_rt::as_i32(t2_14)) as u8;
                    *ptr1.add(15).cast::<u8>() = (_rt::as_i32(t2_15)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_config_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_config();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_config<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                }
                pub trait Guest {
                    /// Get the version of the rudel base
                    ///
                    /// If your module requests newer versions of the modules than the host implements, it will attempt to link its old ones anyways and make them conforme to the requested signatures. You can use this function to get the actual version of the host functions.
                    ///
                    /// If your module requests older versions of the host modules, the host will link compatible functions if available, or abort during linking.
                    ///
                    /// The host will mock out all functions it can not link.
                    fn get_base_version() -> SemanticVersion;
                    /// You need to yield periodically, as the watchdog will kill you if you dont
                    ///
                    /// Will try to sleep for the given duration while still serving callbacks
                    ///
                    /// Use micros = 0 to sleep for the minimum duration
                    ///
                    /// Returns the new fuel amount
                    fn yield_now(micros: u64) -> u32;
                    /// Get the remaining fuel
                    fn get_remaining_fuel() -> u32;
                    /// Sleep for a given amount of time without yielding
                    fn sleep(micros: u64) -> ();
                    /// Returns the number of microseconds that have passed since boot
                    fn time() -> u64;
                    /// Log a message
                    fn log(level: LogLevel, message: _rt::String) -> ();
                    /// The name of this host. It is guaranteed to be unique, and will not change during the lifetime of the host.
                    ///
                    /// The name is returned as a list of 16 bytes to avoid the need for allocations on the host side, as the buffer will be allocated by the guest. The name is UTF-8 encoded, and the buffer will be zero padded after the end of the string.
                    ///
                    /// Once fixed size lists gets stabilized in WIT, this will be changed to a list<u8, 16>. That should not affect the ABI as the representation of a tuple and a fixed size list is the same.
                    ///
                    /// Your host bindings should provide a wrapper for this that converts the list to a string.
                    fn get_name() -> (
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                        u8,
                    );
                    /// Returns the configuration for this guest, as configured over BLE. The
                    /// semantics of the configuration depend on the guest.
                    fn get_config() -> _rt::Vec<u8>;
                }
                #[doc(hidden)]
                macro_rules! __export_rudel_base_base_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "rudel:base/base@0.0.1#get-base-version")] unsafe extern "C" fn
                        export_get_base_version() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_base_version_cabi::<$ty > () } }
                        #[unsafe (export_name = "rudel:base/base@0.0.1#yield-now")]
                        unsafe extern "C" fn export_yield_now(arg0 : i64,) -> i32 {
                        unsafe { $($path_to_types)*:: _export_yield_now_cabi::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "rudel:base/base@0.0.1#get-remaining-fuel")] unsafe extern "C" fn
                        export_get_remaining_fuel() -> i32 { unsafe {
                        $($path_to_types)*:: _export_get_remaining_fuel_cabi::<$ty > () }
                        } #[unsafe (export_name = "rudel:base/base@0.0.1#sleep")] unsafe
                        extern "C" fn export_sleep(arg0 : i64,) { unsafe {
                        $($path_to_types)*:: _export_sleep_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name = "rudel:base/base@0.0.1#time")] unsafe
                        extern "C" fn export_time() -> i64 { unsafe {
                        $($path_to_types)*:: _export_time_cabi::<$ty > () } } #[unsafe
                        (export_name = "rudel:base/base@0.0.1#log")] unsafe extern "C" fn
                        export_log(arg0 : i32, arg1 : * mut u8, arg2 : usize,) { unsafe {
                        $($path_to_types)*:: _export_log_cabi::<$ty > (arg0, arg1, arg2)
                        } } #[unsafe (export_name = "rudel:base/base@0.0.1#get-name")]
                        unsafe extern "C" fn export_get_name() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_name_cabi::<$ty > () } }
                        #[unsafe (export_name = "rudel:base/base@0.0.1#get-config")]
                        unsafe extern "C" fn export_get_config() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_config_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_rudel:base/base@0.0.1#get-config")] unsafe extern "C"
                        fn _post_return_get_config(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_get_config::<$ty > (arg0) } }
                        };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_rudel_base_base_0_0_1_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 16],
                );
            }
            /// Use this interface to control the hardware
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod hardware {
                use super::super::super::super::_rt;
                pub type SemanticVersion = super::super::super::super::exports::rudel::base::base::SemanticVersion;
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct LedColor {
                    pub red: u8,
                    pub green: u8,
                    pub blue: u8,
                }
                impl ::core::fmt::Debug for LedColor {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LedColor")
                            .field("red", &self.red)
                            .field("green", &self.green)
                            .field("blue", &self.blue)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct LedInfo {
                    pub color: LedColor,
                    pub max_lux: u16,
                }
                impl ::core::fmt::Debug for LedInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LedInfo")
                            .field("color", &self.color)
                            .field("max-lux", &self.max_lux)
                            .finish()
                    }
                }
                /// Information about the ambient light sensor.
                ///
                /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AmbientLightType {
                    None,
                    Basic,
                }
                impl ::core::fmt::Debug for AmbientLightType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AmbientLightType::None => {
                                f.debug_tuple("AmbientLightType::None").finish()
                            }
                            AmbientLightType::Basic => {
                                f.debug_tuple("AmbientLightType::Basic").finish()
                            }
                        }
                    }
                }
                impl AmbientLightType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AmbientLightType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AmbientLightType::None,
                            1 => AmbientLightType::Basic,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Information about the vibration sensor.
                ///
                /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum VibrationSensorType {
                    None,
                    Ball,
                }
                impl ::core::fmt::Debug for VibrationSensorType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            VibrationSensorType::None => {
                                f.debug_tuple("VibrationSensorType::None").finish()
                            }
                            VibrationSensorType::Ball => {
                                f.debug_tuple("VibrationSensorType::Ball").finish()
                            }
                        }
                    }
                }
                impl VibrationSensorType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> VibrationSensorType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => VibrationSensorType::None,
                            1 => VibrationSensorType::Ball,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Information about the supply voltage sensor.
                ///
                /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum VoltageSensorType {
                    None,
                    Basic,
                }
                impl ::core::fmt::Debug for VoltageSensorType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            VoltageSensorType::None => {
                                f.debug_tuple("VoltageSensorType::None").finish()
                            }
                            VoltageSensorType::Basic => {
                                f.debug_tuple("VoltageSensorType::Basic").finish()
                            }
                        }
                    }
                }
                impl VoltageSensorType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> VoltageSensorType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => VoltageSensorType::None,
                            1 => VoltageSensorType::Basic,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_hardware_version_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_hardware_version();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::rudel::base::base::SemanticVersion {
                        major: major2,
                        minor: minor2,
                        patch: patch2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(major2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(minor2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(patch2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_set_leds_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let result1 = T::set_leds(
                        arg0 as u16,
                        _rt::Vec::from_raw_parts(arg1.cast(), len0, len0),
                    );
                    _rt::as_i32(result1)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_set_rgb_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::set_rgb(
                        LedColor {
                            red: arg0 as u8,
                            green: arg1 as u8,
                            blue: arg2 as u8,
                        },
                        arg3 as u32,
                    );
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_led_count_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::led_count();
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_led_info_cabi<T: Guest>(arg0: i32) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_led_info(arg0 as u16);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let LedInfo { color: color2, max_lux: max_lux2 } = result0;
                    let LedColor { red: red3, green: green3, blue: blue3 } = color2;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(red3)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(green3)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(blue3)) as u8;
                    *ptr1.add(4).cast::<u16>() = (_rt::as_i32(max_lux2)) as u16;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_ambient_light_type_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_ambient_light_type();
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_ambient_light_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_ambient_light();
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_vibration_sensor_type_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_vibration_sensor_type();
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_vibration_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_vibration();
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_voltage_sensor_type_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_voltage_sensor_type();
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_voltage_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_voltage();
                    _rt::as_i32(result0)
                }
                pub trait Guest {
                    /// Get the version of the hardware interface provided by the runtime.
                    ///
                    /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
                    fn get_hardware_version() -> SemanticVersion;
                    /// Lowlevel function to set the intensities of multiple LEDs
                    ///
                    /// The values are in lux in the main direction of the LED
                    ///
                    /// You should probably not use this function directly, but use a higher level abstraction instead
                    ///
                    /// The first-id is the index of the first LED to set. If the lux list is shorter than the number of LEDs, the remaining LEDs will not be modified. If the lux list is longer than the number of LEDs, the remaining values will be ignored.
                    fn set_leds(first_id: u16, lux: _rt::Vec<u16>) -> u32;
                    /// Convenience function to set all LEDs
                    fn set_rgb(color: LedColor, lux: u32) -> u32;
                    /// Get information about the number of LEDs
                    fn led_count() -> u32;
                    /// Get information about a specific LED
                    ///
                    /// If the id does not exist, the function will return a led-info with all values set to 0
                    fn get_led_info(id: u16) -> LedInfo;
                    /// Information about the ambient light sensor.
                    ///
                    /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
                    fn get_ambient_light_type() -> AmbientLightType;
                    /// Get the current ambient light level
                    ///
                    /// The value is in lux
                    fn get_ambient_light() -> u32;
                    /// Vibration sensor type.
                    fn get_vibration_sensor_type() -> VibrationSensorType;
                    /// Get a measure of the vibration level
                    ///
                    /// TODO: Figure out what this should return
                    fn get_vibration() -> u32;
                    /// Voltage sensor type.
                    fn get_voltage_sensor_type() -> VibrationSensorType;
                    /// Get the current supply voltage
                    ///
                    /// The value is in millivolts
                    fn get_voltage() -> u32;
                }
                #[doc(hidden)]
                macro_rules! __export_rudel_base_hardware_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-hardware-version")] unsafe extern
                        "C" fn export_get_hardware_version() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_hardware_version_cabi::<$ty > ()
                        } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#set-leds")] unsafe extern "C" fn
                        export_set_leds(arg0 : i32, arg1 : * mut u8, arg2 : usize,) ->
                        i32 { unsafe { $($path_to_types)*:: _export_set_leds_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#set-rgb")] unsafe extern "C" fn
                        export_set_rgb(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,)
                        -> i32 { unsafe { $($path_to_types)*:: _export_set_rgb_cabi::<$ty
                        > (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#led-count")] unsafe extern "C" fn
                        export_led_count() -> i32 { unsafe { $($path_to_types)*::
                        _export_led_count_cabi::<$ty > () } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-led-info")] unsafe extern "C" fn
                        export_get_led_info(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_led_info_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-ambient-light-type")] unsafe
                        extern "C" fn export_get_ambient_light_type() -> i32 { unsafe {
                        $($path_to_types)*:: _export_get_ambient_light_type_cabi::<$ty >
                        () } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-ambient-light")] unsafe extern "C"
                        fn export_get_ambient_light() -> i32 { unsafe {
                        $($path_to_types)*:: _export_get_ambient_light_cabi::<$ty > () }
                        } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-vibration-sensor-type")] unsafe
                        extern "C" fn export_get_vibration_sensor_type() -> i32 { unsafe
                        { $($path_to_types)*::
                        _export_get_vibration_sensor_type_cabi::<$ty > () } } #[unsafe
                        (export_name = "rudel:base/hardware@0.0.1#get-vibration")] unsafe
                        extern "C" fn export_get_vibration() -> i32 { unsafe {
                        $($path_to_types)*:: _export_get_vibration_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-voltage-sensor-type")] unsafe
                        extern "C" fn export_get_voltage_sensor_type() -> i32 { unsafe {
                        $($path_to_types)*:: _export_get_voltage_sensor_type_cabi::<$ty >
                        () } } #[unsafe (export_name =
                        "rudel:base/hardware@0.0.1#get-voltage")] unsafe extern "C" fn
                        export_get_voltage() -> i32 { unsafe { $($path_to_types)*::
                        _export_get_voltage_cabi::<$ty > () } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_rudel_base_hardware_0_0_1_cabi;
                #[repr(align(2))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 6]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 6],
                );
            }
            /// Control ble stuff
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod ble {
                use super::super::super::super::_rt;
                pub type SemanticVersion = super::super::super::super::exports::rudel::base::base::SemanticVersion;
                /// A service UUID, can be a shortened one
                #[derive(Clone, Copy)]
                pub enum ServiceUuid {
                    Uuid16(u16),
                    Uuid32(u32),
                    Uuid128((u64, u64)),
                }
                impl ::core::fmt::Debug for ServiceUuid {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ServiceUuid::Uuid16(e) => {
                                f.debug_tuple("ServiceUuid::Uuid16").field(e).finish()
                            }
                            ServiceUuid::Uuid32(e) => {
                                f.debug_tuple("ServiceUuid::Uuid32").field(e).finish()
                            }
                            ServiceUuid::Uuid128(e) => {
                                f.debug_tuple("ServiceUuid::Uuid128").field(e).finish()
                            }
                        }
                    }
                }
                /// Service specific data
                #[derive(Clone)]
                pub struct ServiceData {
                    pub uuid: ServiceUuid,
                    pub data: _rt::Vec<u8>,
                }
                impl ::core::fmt::Debug for ServiceData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ServiceData")
                            .field("uuid", &self.uuid)
                            .field("data", &self.data)
                            .finish()
                    }
                }
                /// Manufacturer specific data
                #[derive(Clone)]
                pub struct ManufacturerData {
                    pub company_id: u16,
                    pub data: _rt::Vec<u8>,
                }
                impl ::core::fmt::Debug for ManufacturerData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ManufacturerData")
                            .field("company-id", &self.company_id)
                            .field("data", &self.data)
                            .finish()
                    }
                }
                /// Configure the BLE advertisements
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct AdvertisementInterval {
                    pub min_interval: u16,
                    pub max_interval: u16,
                }
                impl ::core::fmt::Debug for AdvertisementInterval {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AdvertisementInterval")
                            .field("min-interval", &self.min_interval)
                            .field("max-interval", &self.max_interval)
                            .finish()
                    }
                }
                /// Sendable BLE advertisement data
                ///
                /// Can be at most 31 bytes - (size of the name + 6 bytes)
                #[derive(Clone)]
                pub struct EncodedData {
                    /// Include the transmission power. (3 bytes)
                    pub include_tx_power: bool,
                    /// service UUIDs (2 bytes per used class (16, 32, 128 bit UUID) + size of the UUIDs)
                    pub uuids: _rt::Vec<ServiceUuid>,
                    /// service data (2 byte + size of the UUID + size of data) for each service data)
                    pub service_data: _rt::Vec<ServiceData>,
                    /// appearance (4 byte)
                    pub appearance: Option<u16>,
                    /// manufacturer specific data (2 byte + 2 byte company ID + size of data)
                    pub manufacturer_data: Option<ManufacturerData>,
                }
                impl ::core::fmt::Debug for EncodedData {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("EncodedData")
                            .field("include-tx-power", &self.include_tx_power)
                            .field("uuids", &self.uuids)
                            .field("service-data", &self.service_data)
                            .field("appearance", &self.appearance)
                            .field("manufacturer-data", &self.manufacturer_data)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_ble_version_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_ble_version();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::rudel::base::base::SemanticVersion {
                        major: major2,
                        minor: minor2,
                        patch: patch2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (_rt::as_i32(major2)) as u8;
                    *ptr1.add(1).cast::<u8>() = (_rt::as_i32(minor2)) as u8;
                    *ptr1.add(2).cast::<u8>() = (_rt::as_i32(patch2)) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_configure_advertisement_interval_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::configure_advertisement_interval(AdvertisementInterval {
                        min_interval: arg0 as u16,
                        max_interval: arg1 as u16,
                    });
                    let result1 = match result0 {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    result1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_set_advertisement_data_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: *mut u8,
                    arg10: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let base6 = arg1;
                    let len6 = arg2;
                    let mut result6 = _rt::Vec::with_capacity(len6);
                    for i in 0..len6 {
                        let base = base6.add(i * 24);
                        let e6 = {
                            let l0 = i32::from(*base.add(0).cast::<u8>());
                            let v5 = match l0 {
                                0 => {
                                    let e5 = {
                                        let l1 = i32::from(*base.add(8).cast::<u16>());
                                        l1 as u16
                                    };
                                    ServiceUuid::Uuid16(e5)
                                }
                                1 => {
                                    let e5 = {
                                        let l2 = *base.add(8).cast::<i32>();
                                        l2 as u32
                                    };
                                    ServiceUuid::Uuid32(e5)
                                }
                                n => {
                                    debug_assert_eq!(n, 2, "invalid enum discriminant");
                                    let e5 = {
                                        let l3 = *base.add(8).cast::<i64>();
                                        let l4 = *base.add(16).cast::<i64>();
                                        (l3 as u64, l4 as u64)
                                    };
                                    ServiceUuid::Uuid128(e5)
                                }
                            };
                            v5
                        };
                        result6.push(e6);
                    }
                    _rt::cabi_dealloc(base6, len6 * 24, 8);
                    let base16 = arg3;
                    let len16 = arg4;
                    let mut result16 = _rt::Vec::with_capacity(len16);
                    for i in 0..len16 {
                        let base = base16
                            .add(i * (24 + 2 * ::core::mem::size_of::<*const u8>()));
                        let e16 = {
                            let l7 = i32::from(*base.add(0).cast::<u8>());
                            let v12 = match l7 {
                                0 => {
                                    let e12 = {
                                        let l8 = i32::from(*base.add(8).cast::<u16>());
                                        l8 as u16
                                    };
                                    ServiceUuid::Uuid16(e12)
                                }
                                1 => {
                                    let e12 = {
                                        let l9 = *base.add(8).cast::<i32>();
                                        l9 as u32
                                    };
                                    ServiceUuid::Uuid32(e12)
                                }
                                n => {
                                    debug_assert_eq!(n, 2, "invalid enum discriminant");
                                    let e12 = {
                                        let l10 = *base.add(8).cast::<i64>();
                                        let l11 = *base.add(16).cast::<i64>();
                                        (l10 as u64, l11 as u64)
                                    };
                                    ServiceUuid::Uuid128(e12)
                                }
                            };
                            let l13 = *base.add(24).cast::<*mut u8>();
                            let l14 = *base
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len15 = l14;
                            ServiceData {
                                uuid: v12,
                                data: _rt::Vec::from_raw_parts(l13.cast(), len15, len15),
                            }
                        };
                        result16.push(e16);
                    }
                    _rt::cabi_dealloc(
                        base16,
                        len16 * (24 + 2 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result18 = T::set_advertisement_data(EncodedData {
                        include_tx_power: _rt::bool_lift(arg0 as u8),
                        uuids: result6,
                        service_data: result16,
                        appearance: match arg5 {
                            0 => None,
                            1 => {
                                let e = arg6 as u16;
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        manufacturer_data: match arg7 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len17 = arg10;
                                    ManufacturerData {
                                        company_id: arg8 as u16,
                                        data: _rt::Vec::from_raw_parts(arg9.cast(), len17, len17),
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    let result19 = match result18 {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    result19
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_set_advertisement_data_raw_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::set_advertisement_data_raw(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let result2 = match result1 {
                        Ok(_) => 0i32,
                        Err(_) => 1i32,
                    };
                    result2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_disable_decoded_advertisements_cabi<T: Guest>(
                    arg0: i32,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::disable_decoded_advertisements(_rt::bool_lift(arg0 as u8));
                }
                pub trait Guest {
                    /// Get the version of the hardware interface provided by the runtime.
                    ///
                    /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
                    fn get_ble_version() -> SemanticVersion;
                    /// Configure the interval in which BLE advertisements are sent
                    ///
                    /// Returns an error if the interval is not valid
                    fn configure_advertisement_interval(
                        interval: AdvertisementInterval,
                    ) -> Result<(), ()>;
                    /// Set the advertisement data. The device name will also be added to the advertisement.
                    ///
                    /// If you need more control use set-advertisement-data-raw
                    ///
                    /// Will fail if your data is too long
                    fn set_advertisement_data(data: EncodedData) -> Result<(), ()>;
                    /// Set the raw advertisement data. There will be no additional properties added.
                    ///
                    /// Can be at most 31 bytes
                    ///
                    /// Will fail if your data is too long
                    fn set_advertisement_data_raw(data: _rt::Vec<u8>) -> Result<(), ()>;
                    /// Disable decoded advertisements
                    ///
                    /// true => `on-event` will only receive raw advertisements
                    /// false => `on-event` will decode advertisements, if possible
                    fn disable_decoded_advertisements(disable: bool) -> ();
                }
                #[doc(hidden)]
                macro_rules! __export_rudel_base_ble_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "rudel:base/ble@0.0.1#get-ble-version")] unsafe extern "C" fn
                        export_get_ble_version() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_get_ble_version_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "rudel:base/ble@0.0.1#configure-advertisement-interval")] unsafe
                        extern "C" fn export_configure_advertisement_interval(arg0 : i32,
                        arg1 : i32,) -> i32 { unsafe { $($path_to_types)*::
                        _export_configure_advertisement_interval_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "rudel:base/ble@0.0.1#set-advertisement-data")] unsafe extern "C"
                        fn export_set_advertisement_data(arg0 : i32, arg1 : * mut u8,
                        arg2 : usize, arg3 : * mut u8, arg4 : usize, arg5 : i32, arg6 :
                        i32, arg7 : i32, arg8 : i32, arg9 : * mut u8, arg10 : usize,) ->
                        i32 { unsafe { $($path_to_types)*::
                        _export_set_advertisement_data_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) } } #[unsafe
                        (export_name =
                        "rudel:base/ble@0.0.1#set-advertisement-data-raw")] unsafe extern
                        "C" fn export_set_advertisement_data_raw(arg0 : * mut u8, arg1 :
                        usize,) -> i32 { unsafe { $($path_to_types)*::
                        _export_set_advertisement_data_raw_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name =
                        "rudel:base/ble@0.0.1#disable-decoded-advertisements")] unsafe
                        extern "C" fn export_disable_decoded_advertisements(arg0 : i32,)
                        { unsafe { $($path_to_types)*::
                        _export_disable_decoded_advertisements_cabi::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_rudel_base_ble_0_0_1_cabi;
                #[repr(align(1))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 3]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 3],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_rudel_host_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::rudel::base::base::__export_rudel_base_base_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::rudel::base::base);
        $($path_to_types_root)*::
        exports::rudel::base::hardware::__export_rudel_base_hardware_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::rudel::base::hardware);
        $($path_to_types_root)*::
        exports::rudel::base::ble::__export_rudel_base_ble_0_0_1_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::rudel::base::ble);
    };
}
#[doc(inline)]
pub(crate) use __export_rudel_host_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.41.0:rudel:base@0.0.1:rudel-host:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3265] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc0\x18\x01A\x02\x01\
A\x12\x01B\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\
\0\x09yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06\
microsw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05\
level\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\
\0\x0a\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x03\
\0\x15rudel:base/base@0.0.1\x05\0\x02\x03\0\0\x10semantic-version\x01B\x1d\x02\x03\
\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01o\x02ww\x01q\x03\x06uuid16\x01\
{\0\x06uuid32\x01y\0\x07uuid128\x01\x02\0\x04\0\x0cservice-uuid\x03\0\x03\x01p}\x01\
r\x02\x04uuid\x04\x04data\x05\x04\0\x0cservice-data\x03\0\x06\x01r\x02\x0acompan\
y-id{\x04data\x05\x04\0\x11manufacturer-data\x03\0\x08\x01r\x02\x0cmin-interval{\
\x0cmax-interval{\x04\0\x16advertisement-interval\x03\0\x0a\x01p\x04\x01p\x07\x01\
k{\x01k\x09\x01r\x05\x10include-tx-power\x7f\x05uuids\x0c\x0cservice-data\x0d\x0a\
appearance\x0e\x11manufacturer-data\x0f\x04\0\x0cencoded-data\x03\0\x10\x01@\0\0\
\x01\x04\0\x0fget-ble-version\x01\x12\x01j\0\0\x01@\x01\x08interval\x0b\0\x13\x04\
\0\x20configure-advertisement-interval\x01\x14\x01@\x01\x04data\x11\0\x13\x04\0\x16\
set-advertisement-data\x01\x15\x01@\x01\x04data\x05\0\x13\x04\0\x1aset-advertise\
ment-data-raw\x01\x16\x01@\x01\x07disable\x7f\x01\0\x04\0\x1edisable-decoded-adv\
ertisements\x01\x17\x03\0\x14rudel:base/ble@0.0.1\x05\x02\x02\x03\0\x01\x0cservi\
ce-uuid\x02\x03\0\x01\x0cservice-data\x02\x03\0\x01\x11manufacturer-data\x01B\x1b\
\x02\x03\x02\x01\x03\x04\0\x0cservice-uuid\x03\0\0\x02\x03\x02\x01\x04\x04\0\x0c\
service-data\x03\0\x02\x02\x03\x02\x01\x05\x04\0\x11manufacturer-data\x03\0\x04\x01\
n\x05\x14limited-discoverable\x14general-discoverable\x14br-edr-not-supported\x17\
simultaneous-controller\x11simultaneous-host\x04\0\x13advertisement-flags\x03\0\x06\
\x01m\x05\x08indirect\x0adirect-ind\x0dindirect-scan\x18indirect-not-connectable\
\x0dscan-response\x04\0\x12advertisement-type\x03\0\x08\x01ks\x01k}\x01p\x01\x01\
p\x03\x01k{\x01k\x05\x01r\x07\x04name\x0a\x13advertisement-flags\x07\x08tx-power\
\x0b\x05uuids\x0c\x0cservice-data\x0d\x0aappearance\x0e\x11manufacturer-data\x0f\
\x04\0\x0cdecoded-data\x03\0\x10\x01p}\x01q\x02\x07decoded\x01\x11\0\x03raw\x01\x12\
\0\x04\0\x12advertisement-data\x03\0\x13\x01r\x05\x0breceived-atw\x07addressw\x04\
rssi~\x12advertisement-type\x09\x04data\x14\x04\0\x0dadvertisement\x03\0\x15\x01\
q\x01\x0dadvertisement\x01\x16\0\x04\0\x09ble-event\x03\0\x17\x01@\x01\x05event\x18\
\x01\0\x04\0\x08on-event\x01\x19\x03\0\x1arudel:base/ble-guest@0.0.1\x05\x06\x01\
B\x02\x01@\0\x01\0\x04\0\x03run\x01\0\x03\0\x14rudel:base/run@0.0.1\x05\x07\x01B\
\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\0\0\x01\
m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\0\x02\
\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\0\x09\
yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06micr\
osw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05lev\
el\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\0\x0a\
\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x04\0\x15\
rudel:base/base@0.0.1\x05\x08\x01B\x1f\x02\x03\x02\x01\x01\x04\0\x10semantic-ver\
sion\x03\0\0\x01r\x03\x03red}\x05green}\x04blue}\x04\0\x09led-color\x03\0\x02\x01\
r\x02\x05color\x03\x07max-lux{\x04\0\x08led-info\x03\0\x04\x01m\x02\x04none\x05b\
asic\x04\0\x12ambient-light-type\x03\0\x06\x01m\x02\x04none\x04ball\x04\0\x15vib\
ration-sensor-type\x03\0\x08\x01m\x02\x04none\x05basic\x04\0\x13voltage-sensor-t\
ype\x03\0\x0a\x01@\0\0\x01\x04\0\x14get-hardware-version\x01\x0c\x01p{\x01@\x02\x08\
first-id{\x03lux\x0d\0y\x04\0\x08set-leds\x01\x0e\x01@\x02\x05color\x03\x03luxy\0\
y\x04\0\x07set-rgb\x01\x0f\x01@\0\0y\x04\0\x09led-count\x01\x10\x01@\x01\x02id{\0\
\x05\x04\0\x0cget-led-info\x01\x11\x01@\0\0\x07\x04\0\x16get-ambient-light-type\x01\
\x12\x04\0\x11get-ambient-light\x01\x10\x01@\0\0\x09\x04\0\x19get-vibration-sens\
or-type\x01\x13\x04\0\x0dget-vibration\x01\x10\x04\0\x17get-voltage-sensor-type\x01\
\x13\x04\0\x0bget-voltage\x01\x10\x04\0\x19rudel:base/hardware@0.0.1\x05\x09\x01\
B\x1d\x02\x03\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01o\x02ww\x01q\x03\x06\
uuid16\x01{\0\x06uuid32\x01y\0\x07uuid128\x01\x02\0\x04\0\x0cservice-uuid\x03\0\x03\
\x01p}\x01r\x02\x04uuid\x04\x04data\x05\x04\0\x0cservice-data\x03\0\x06\x01r\x02\
\x0acompany-id{\x04data\x05\x04\0\x11manufacturer-data\x03\0\x08\x01r\x02\x0cmin\
-interval{\x0cmax-interval{\x04\0\x16advertisement-interval\x03\0\x0a\x01p\x04\x01\
p\x07\x01k{\x01k\x09\x01r\x05\x10include-tx-power\x7f\x05uuids\x0c\x0cservice-da\
ta\x0d\x0aappearance\x0e\x11manufacturer-data\x0f\x04\0\x0cencoded-data\x03\0\x10\
\x01@\0\0\x01\x04\0\x0fget-ble-version\x01\x12\x01j\0\0\x01@\x01\x08interval\x0b\
\0\x13\x04\0\x20configure-advertisement-interval\x01\x14\x01@\x01\x04data\x11\0\x13\
\x04\0\x16set-advertisement-data\x01\x15\x01@\x01\x04data\x05\0\x13\x04\0\x1aset\
-advertisement-data-raw\x01\x16\x01@\x01\x07disable\x7f\x01\0\x04\0\x1edisable-d\
ecoded-advertisements\x01\x17\x04\0\x14rudel:base/ble@0.0.1\x05\x0a\x04\0\x1brud\
el:base/rudel-host@0.0.1\x04\0\x0b\x10\x01\0\x0arudel-host\x03\0\0\0G\x09produce\
rs\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.\
41.0";
